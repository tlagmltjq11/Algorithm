▶ 1018.cs
처음 아이디어로 현재 검사순서의 칸과 오른쪽 칸, 아래쪽 칸만 검사하면서 나아가면 자신의 상하좌우의 모든 칸들과 검사할 수 있다는
것에 착안해 문제를 풀어보려 했지만 자신과 자신의 오른쪽, 아래쪽 색이 같다고 했을 때(즉 문제점을 발견했을 때) 어떤 칸의 색을 바꿔줘야 하는지 알 도리가 없었다.
두 번째 아이디어는 8x8 체스판의 가장 맨 왼쪽 위 칸의 색을 토대로 검은색, 흰색 반복으로 검사해나가면서 순서에 맞지 않는 색을 가진 칸을 세어보려 했지만
이는 최솟값을 구할 수 있는 로직이 아니었다. 체스판이 검은색으로 시작할 수도 있는 흰색으로 시작할 수도 있기 때문이다. 
고로 검은색 시작, 흰색 시작 2가지 경우를 모두 체크해나가면서 둘 중 더 최솟값을 갖는 경우를 저장하는 것으로 로직을 구현했다. 

▶ 1436번, 2798번, 2231번 처럼 Brute Force 문제들은 너무 어렵게 생각했다가 오히려 헷갈리는 문제들이 많았다.
브루트포스라는 분류의 뜻 그대로 심플하게 전체순회 로직으로 접근하고, 그 후 시간을 단축 시킬 수 있는 방안을 생각해보는 것이 좋겠다.

▶ 18111.cs 마인크래프트 문제 ★
N X M으로 이루어진 바닥을 최소의 시간 및 최대의 높이로 평평하게 만드는 문제다.
N X M 2차원 배열을 입력받을 때, 최솟값과 최댓값을 구해놓고 최솟값~최댓값 사이의 높이로
완전탐색하면 되는 문제다. 해당 높이로 평탄화 할 때, 걸리는 시간과 인벤토리에 남는 블록의 수를
구해야 한다. 만약 인벤토리에 블록이 음수 값이 되어있다면 해당 높이로 맞출 수 없다는 의미기에
다음 탐색으로 넘어간다.

▶ 1107.cs 리모컨 ★★★
처음엔 브루트포스로 풀면 시간초과가 날 줄 알고 고장나지 않은 버튼들로 원하는 채널에 최대한 가까운 수를 만들어내고
+,-로만 가는것과 숫자버튼으로 최대한 가까이 간 후 +, - 로 가는 2경우를 비교해서 최소값을 출력하도록 했다.
헌데 몇가지 반례들이 존재해서 포스팅을 참고하던 중.. 그냥 완전탐색으로 현재 버튼들로 만들 수 있는 모든 경우의 수를
체크해주면 되는 간단한 문제였다.. 시간허비