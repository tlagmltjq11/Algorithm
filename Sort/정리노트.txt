▶ 2750.cs
제약 시간복잡도가 n^2이니 간단하게 버블정렬로 구현.

▶ 2751.cs
제약 시간복잡도가 nlogn정도로 잡혀있어서, c#으로 퀵소트를 직접구현해보았는데 최악의 경우 때문인지 통과하지못했다.
그래서 피벗을 중간으로 잡도록하여, 최악의 경우를 면하게 했는데 그래도 통과를 못했다..
console.Writeline() 문제인가 싶어서 스트링빌더를 이용해 출력했는데 그래도?? 통과를 못했다.
역시 Mono 때문에 c#은 통과하기 힘든것 같다.
-> 결국 c언어로 변경하여 내장함수인 qsort를 이용해서 통과했다.

▶ 10989.cs
counting sort라는 재미있는 방법을 알게되었던 문제.
카운팅소트는  arr[입력받은수]++ 과 같은 방식으로 인덱스를 이용해 입력과 동시에 자동 정렬이 되도록 유도하는 방식이다.
하지만 입력받을 수의 범위가 한정된 경우에만 사용이 가능하며, 공간복잡도보다 시간복잡도에만 치중한 경우에 사용하기 좋은
방식이다. -> 역시나 c#으로 통과하기에 무리가있어 c언어를 이용했다.

▶ 2108.cs
인풋의 범위에 음수가 포함되더라도 카운팅소트를 사용할 수 있는 편법을 알 수 있던 문제다.
인풋은 -4000 ~ 4000이었는데 8000짜리 크기의 배열을 선언하고 인풋 + 4000을 해주는 방식이다.

▶ 10814.cs
Linq를 사용해본 문제.
Linq에서 제공하는 orderby, thenby를 이용해서 문제에서 요구하는 조건대로 정렬함.

▶ 1181.cs
IComparer 인터페이스를 상속해 Compare메서드를 문제에서 요구하는 조건대로 정렬될 수 있게끔 정의하여 사용함.

  1) IComparable 인터페이스
    - 정의: 정렬 수행시 기본적으로 적용되는 정렬 기준이 되는 메서드를 정의해 놓는 인터페이스이다.
    - 사용법: Comparable 인터페이스를 상속 한 뒤, 내부에 있는 compareTo 메서드를 원하는 정렬 기준대로 구현하여 사용할 수 있다.

  2) IComparer 인터페이스
    - 정의: 정렬 가능한 클래스(=Comparable이 구현된 클래스)들의 기본 정렬 기준과는 다른 방식으로 정렬하고 싶을 때 사용하는 클래스이다.
    - 사용법: IComparer 인터페이스를 상속하여, 내부에 compare메서드를 원하는 정렬 기준대로 구현하여 사용할 수 있다.
