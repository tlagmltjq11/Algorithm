▶1003.cs
n번째 피보나치수를 구할때 fibo(0), fibo(1)이 몇번이나 호출되는지 구하는 문제였다.
당연히 기본 재귀를 이용하면 시간초과가 뜨게된다.
고로 Memoization을 이용해서 즉 동적프로그래밍을 이용해야한다.

규칙을 찾아보면 fibo(n)에 대해서 fibo(1)호출 횟수는 fibo(n)과 같고 
fibo(0)호출 횟수는 fibo(n-1)의 값과 같다.

고로 기본 fibonacci 메소드를 구현한 후 위처럼 출력해주면된다.
                one = fibonacci(fibo);
                zero = fibonacci(fibo - 1);


▶ 9184.cs
문제에서 메소드가 주어져있으며, 해당 재귀형식 동적프로그래밍으로 바꿔주기만 하면 되는 문제다.
고로 값이 계산이 되어있는지 판별 후 되어있다면 바로 return, 되어있지않다면
계산 후 저장하고 return해주면 된다.


▶ 1904.cs
1과 00으로 만들 수 있는 모든 2진수의 갯수를 구하는 문제.
-> 규칙을 찾아보면 피보나치 수와 똑같은 결과가 나옴.



▶ 9461.cs
파도반 수열이 주어지는데, 해당 수열의 규칙을 찾아보면
N번째 파도반 수 = N-1번째 파도반 수 + N-5번째 파도반 수 라는 점화식을 찾을 수 있게 된다.
고로 1~5번째 수 까지는 직접 초기화를 해주고 6번째 수 부터 반복문을 돌면서
위 점화식으로 모든 파도반 수를 구해놓으면 되는 간단한 문제이다.




▶ 1149.cs
해당 문제는 쉽게 해결하지 못했다.
처음에는 백트래킹처럼 모든 경우의 수를 가지치기하며 따져보는 방식만이 떠올랐는데
해당 방식은 DP도 아닐뿐더러 시간초과가 우려되어 시도하지 않았다.
결국 여러 자료들을 참고하며 풀어냈다.

->>
인접한 집끼리는 같은 색깔로 칠할 수 없기 때문에 이전 집 페인트 값 중 현재 집에 칠할 색을 제외하고 minimum 값을 구한다.
그것과 현재 집에 칠하려 했던 색을 더하여 dp 배열에 저장한다. 
즉, 빨강색을 색칠하려한다면 이전 집의 초록색, 이전 집의 파랑색 중 더 작은 값에 현재 집에 빨강색 값을 더하여 저장하는 것이다.
이 과정을 N-1 번째 집까지 반복하고 그 집에 기록되어있는 R,G,B 중 최솟값을 구하면 된다.

라운드(?)가 진행된만큼 cost의 누적값을 유지해야 하는것이 포인트인 문제같다.★




▶ 1932.cs
피라미드 형식으로 이루어진 수의 집합에서 위에서부터 숫자를 대각선으로만 선택하며 내려와
구할 수 있는 최대값을 출력하는 문제였다.
너무도 단순하게, 가장 위에 존재하는 수 부터 자신의 왼쪽아래, 오른쪽아래 대각선의 수와 
자신을 더한 값이 해당 대각선의 원래 위치하던 값보다 큰 경우 값을 대체해주도록 반복하면 된다.

	      5					      
	     
	3	5

      2           1           6

(첫번째 수 5) : 5 + 3 이 3보다 크므로 8로 대체, 5 + 5가 5보다 크므로 10으로 대체

	      5
	     
	8	10

      2           1           6	

(두번째 수 8) : 8 + 2 가 2보다 크므로 10으로 대체, 8 + 1이 1보다 크므로 9로 대체 

	      5
	     
	8	10

      10          9           6	

(세번째 수 10) : 10 + 1이 9보다 크므로 11로 대체, 10 + 6이 6보다 크므로 16으로 대체

	      5
	     
	8	10

      2           11          16	

최종적으로 16이 최대값이 된다.

여기서 중요한점은 각 수 까지로 이동하는 최대값의 경우를 저장해가면서 진행한다는 점.★





▶ 2579.cs (중상)
3개의 연속된 계단을 밟지못하고, 한번에 1칸 혹은 2칸만 올라갈 수 있는것이 조건.

처음 아이디어 -> n번째 계단에 도착하려면 n-1번째 혹은 n-2번째 계단에 도착해야 하므로
n-1번, n-2번째 계단에 도착하는 최댓값과 n번째 계단값의 합을 비교하려 했다.
이대로만 진행하게되면, n-1번째에 도착한 경우를 비교할때 연속된 3개의 계단을
밟게되는 경우가 생길 수 있었다.

최종 아이디어
-> n번째 계단에 도착하기 위해서 n-1, n-2번째 계단을 밟아야 하기 때문에
Max( n-1번째 계단값 + n-3번째 계단까지의 최대값 + n번째 계단값,  n-2번째 계단까지의 최대값 + n번째 계단값)
위와 같은 식이 성립되어야만 한다.
그래야 3개의 연속된 계단을 밟게되는 경우를 배제할 수 있다.




▶ 1463.cs (상)
기존의 DP문제처럼 패턴을 찾아보려 했지만 보이지않았고, 3으로 나누는 것이 가장 수를 빠르게
작게 만들 수 있는 경우라 생각도 해보았지만 제시해준 10으로 진행해보면 바로 반례가 나오게되었다.
결국 여러 힌트를 참고해서 풀게되었는데 DP는 패턴을 찾고 점화식을 세워서 푼다! 라는 고정관념이 있어
문제를 쉽게 풀지 못한 것 같다. 물론 점화식을 세워서 푸는 것은 맞지만 너무 패턴을 찾는데만 집중하지
말고 넓게 생각할 줄 알아야 할 것 같다.

예시) 4의 경우
d[4를 1로 만드는 최소 횟수] = 
  (1) N-1을 하면 N=3이 되고, 다시 N/3을 하면 1이 된다. => 2번
  (2) N/2를 하면 N=2가 되고, 다시 N/2나 N-1을 하면 1이 된다. => 2번
  (3) N/3의 경우는 불가능하다.
결국 이 경우의 수 중에서 제일 작은 값인 2번이 된다.

즉 N을 최소 횟수로 1로 만드는 과정은 "주어진 수(N)에서 -1또는 /2 또는 /3을 통해 수를 최소 횟수로 
줄여나가 1까지 만든다"의 사고과정을 따른다. 
->>
주어진 수(N)을 1로 만드는 최소 횟수는 =  'N-1을 1로 만드는 최소 횟수 + 1번' 또는
 'N/2를 1로 만드는 최소 횟수 +1번' 또는 'N/3을 1로 만드는 최소 횟수 + 1번' 이 된다.
이를 식으로 표현하면 d[N을 1로 만드는 최소 횟수] = d[N-1을 1로 만드는 최소 횟수]
 + 1번 or d[N/2를 1로 만드는 최소 횟수] + 1번 or D[N/3을 1로 만드는 최소 횟수] + 1번이 된다.

//코드로 표현하자면 아래와 같다.

                // N값에 -1을 한 경우에 대해서 최소값을 dp로 구한다.
                dp[i] = dp[i - 1] + 1;

                // N값에 /2가 가능하다면 해당 경우에 대해서 최소값을 dp로 구한다.
                if (i % 2 == 0)
                {
                    dp[i] = Math.Min(dp[i], dp[i / 2] + 1);
                }

                // N값에 /3이 가능하다면 해당 경우에 대해서 최소값을 dp로 구한다.
                if (i % 3 == 0)
                {
                    dp[i] = Math.Min(dp[i], dp[i / 3] + 1);
                }

                //최종적으로 -1, /2, /3 각 결과중 가장 최소값이 저장되게 된다.





▶ 10844.cs (중)
인접한 모든 자리수가 1의 차이를 가져야하는 조건에서 n이 주어질때, n인 계단 수가 총 몇개인지 구하는 문제.
우선 DP같은 경우 메모이제이션을 이용해야하기 때문에, 어떤 부분이 중복계산 되는지 생각해보았다.
-> 1~9 까지 +1 -1 해보면서 진행하는 문제에서는 전혀 사용할 수 없었음.
-> 주어진 n마다 1~9로 시작하는 n자리수의 계단 수의 갯수를 메모이제이션에 이용할 수 있지 않을까 생각해보게됨.
<자릿수가 1씩 증가되므로, 이전에 계산했던 갯수를 이용 가능하기 때문임.>

먼저 1~9로 시작하는 계단 수를 n이 1, 2, 3일때 나열을 해보았다.

n = 1		n = 2		n = 3

1) 1		10, 12		101, 121, 123
2) 2		21, 23		210, 212, 232, 234
3) 3 		32, 34		321, 323, 343, 345
4) 4		43, 45		....
5) 5		54, 56
6) 6		65, 67
7) 7		76, 78
8) 8		87, 89
9) 9		98

n = 3일때 2로 시작하는 계단수의 경우 맨앞의수 2를 제외하면 10, 12, 32, 34로  n = 2일때의 1, 3으로 시작하는 계단 수의
합이라는 점을 찾아냈다.
이점을 메모이제이션을 통해서 DP로 문제를 해결할 수 있을 것 같았다.
하지만, 1, 9로 시작하는 경우에는 예외가 발생했다. -> 결국 해결하지 못함.

다시 수들을 자세히 살펴보니, 시작하는 수가 아니라 끝나는 수를 기준으로 봐야한다는것을 알 수 있었다.
0으로 끝나는 수는 -1을 뒤에 덧붙일 수 없으니 1만 덧붙여주고, 9로 끝나는 수는 10을 덧붙여 줄 수 없으니
8만 덧붙여준다면 위에서 생각했던 아이디어와는 달리 모든 경우를 해결 할 수 있었다.

고로 n이 1,2,3일때 0~9로 끝나는 계단 수의 갯수를 다시 나열하였고
dp[i, j] = (dp[i - 1, j - 1] + dp[i - 1, j + 1]) 와 같은 점화식을 얻어낼 수 있었다.

DP문제들은 항상 번뜩이는 아이디어를 떠올려야하는 점이 어려운 것 같다..



▶ 2156.cs (상)
이전에 풀었던 계단수와 비슷한 유형이지만, 왜인지 점화식을 구해내기 어려웠던 문제.
이 문제 같은경우는 포도주를 세개를 연속을 먹을 수없다는 것을 고려해서 메모라이션 하면 된다.

즉 현재 먹는 포도주의 합이 최대일 경우를 생각해보면 

- 내가 현재의 포도주를 먹지 않았을 경우와

- 현재의 포도주를 마시고 이전꺼를 안마실 경우

- 현재의 포도주와 이전의 포도주를 마신 경우

이렇게 3개의 경우를 따져서 저장해 주면 된다. 

- Dp[i-1] : 내가 현재의 포도주를 먹지 않았을 경우와

- wine[i] + Dp[i-2] : 현재의 포도주를 마시고 이전꺼를 안마실 경우

- wine[i] + wine[i-1] + Dp[i-3] :현재의 포도주와 이전의 포도주를 마신 경우

최종식 -> dp[i] = Math.Max(dp[i - 3] + wine[i - 1] + wine[i], Math.Max(dp[i - 1], dp[i - 2] + wine[i]));



▶ 11053.cs (상)
2156과 마찬가지로 아이디어를 떠올리지 못해서 실패했던 문제다..
이전값들을 이용해야한다는 DP의 특성을 잘 고려해서 생각해보는 연습이 필요할 것 같다.

풀이법은 간단했다.
우선 DP[] 배열에 수열의 각 수마다 자신포함 이전까지 최대수열의 길이를 저장하도록 해야한다.
이를 위해서 수열을 왼쪽부터 서치하는데, 현재 수보다 작은값을 가진 이전의 수들을 모두 서치하여
DP값이 제일 큰 즉 제일 긴 수열값을 갖고있는 요소를 찾는다.
찾았다면, 해당 수열에 현재 수를 포함시키면 되므로 +1한 값을 현재 DP[i]에 저장해주면 된다.

최종적으로 DP배열을 순회하면서 가장 큰 max값을 출력해주면 된다.
https://wootool.tistory.com/96  <-- 그림설명 참조

▶ 11054.cs (중)
가장 긴 증가하는 부분수열(11053문제) + 가장 긴 감소하는 부분수열 을 합쳐놓았을 때, 
가장 최대길이가 되는 수열을 찾는 문제이다.

▶ 2565.cs (중상)
문제에 LIS 문제를 응용해야한다고 써있어서 나름의 힌트를 얻을 수 있었지만, 최종 아이디어까지 도달하진
못했다.
우선 a 전봇대의 순서대로 두 배열을 정렬해놓고 패턴을 찾아보면
b 전봇대의 값이 이전 값보다 줄어들때 선이 꼬이게된다는 사실을 알 수 있다.
이전값보다 크다면 선이 꼬이지 않고, 이전값과 같을 순 없기에 값이 줄어드는 경우만 따져보면 된다.
-> 이말은 즉슨 가장 긴 증가 수열을 b 배열에서 찾으면 되는 것이었다. ★★

b배열에서 가장 긴 증가 수열을 11053문제와 동일하게 구한 후 전체 전깃줄의 개수에서 빼주면된다.

▶ 1912.cs (하)
정답률과는 별개로 몇분내로 풀린 쉬운 문제였다.
주어진 임의의 수열에서 연속된 수를 선택해 가장 큰 합을 구하는 문제.

DP를 이용하기 위해 문제를 작은 수열 내에서 가장 큰 합을 구하는 문제로 분할시켰고, 해당 값들을
메모이제이션하며 풀어나갈 수 있도록 유도했다.

맨처음 아이디어로 음수값은 더하지않는것이 좋겠다고 생각했지만, 해당 음수값을 더하지않음으로써
더 큰 연속된값을 놓치는 경우가 있어 다른 아이디어를 생각했다.
다른 아이디어는 결국 음수값을 더하더라도 결과값이 양수이기만하면 계속해서 더하는것이 가장 큰 수를
만들 수 있는것이므로 앞에서부터 계속 더해가다가 이전 dp의 값이 음수일때만 즉 오히려 더하는것이 
독이 될 경우에만 더하지않도록 처리해주면 됐다.

이전 DP값이 음수일 경우에는 현재 DP값을 그냥 자신의 수로 지정해준다.
DP[i-1] < 0 -> DP[i] = nums[i];

그 반대의 경우에는 더해주면 된다.
DP[i] = DP[i - 1] + nums[i];

▶ 12865.cs (중상)
알고리즘 과목시간에도 배웠던 냅색(배낭채우기) 문제이다.
백트래킹으로는 풀어본적이 있으나 DP로는 풀어본적이 없어서 많이 헤맨 문제.

각 물품에대해서 해당 물품을 선택할 경우, 선택하지 않을 경우를 따져줘야 한다.
선택가능한 즉 해당 물품을 추가해도 가방이 견딜 수 있는 경우에만 물품을 선택한 경우를 처리해준다.
이런식으로 일반 백트래킹을 이용하면 시간복잡도가 2^n 이므로 시간초과가 걸릴 것이다.
-> 메모이제이션 사용.

https://www.youtube.com/watch?v=frlRE7bRIDo 참고