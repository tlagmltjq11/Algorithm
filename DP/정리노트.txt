1003.cs
n번째 피보나치수를 구할때 fibo(0), fibo(1)이 몇번이나 호출되는지 구하는 문제였다.
당연히 기본 재귀를 이용하면 시간초과가 뜨게된다.
고로 Memoization을 이용해서 즉 동적프로그래밍을 이용해야한다.

규칙을 찾아보면 fibo(n)에 대해서 fibo(1)호출 횟수는 fibo(n)과 같고 
fibo(0)호출 횟수는 fibo(n-1)의 값과 같다.

고로 기본 fibonacci 메소드를 구현한 후 위처럼 출력해주면된다.
                one = fibonacci(fibo);
                zero = fibonacci(fibo - 1);

9184.cs
문제에서 메소드가 주어져있으며, 해당 재귀형식 동적프로그래밍으로 바꿔주기만 하면 되는 문제다.
고로 값이 계산이 되어있는지 판별 후 되어있다면 바로 return, 되어있지않다면
계산 후 저장하고 return해주면 된다.

1904.cs
1과 00으로 만들 수 있는 모든 2진수의 갯수를 구하는 문제.
-> 규칙을 찾아보면 피보나치 수와 똑같은 결과가 나옴.

9461.cs
파도반 수열이 주어지는데, 해당 수열의 규칙을 찾아보면
N번째 파도반 수 = N-1번째 파도반 수 + N-5번째 파도반 수 라는 점화식을 찾을 수 있게 된다.
고로 1~5번째 수 까지는 직접 초기화를 해주고 6번째 수 부터 반복문을 돌면서
위 점화식으로 모든 파도반 수를 구해놓으면 되는 간단한 문제이다.

1149.cs
해당 문제는 쉽게 해결하지 못했다.
처음에는 백트래킹처럼 모든 경우의 수를 가지치기하며 따져보는 방식만이 떠올랐는데
해당 방식은 DP도 아닐뿐더러 시간초과가 우려되어 시도하지 않았다.
결국 여러 자료들을 참고하며 풀어냈다.

->>
인접한 집끼리는 같은 색깔로 칠할 수 없기 때문에 이전 집 페인트 값 중 현재 집에 칠할 색을 제외하고 minimum 값을 구한다.
그것과 현재 집에 칠하려 했던 색을 더하여 dp 배열에 저장한다. 
즉, 빨강색을 색칠하려한다면 이전 집의 초록색, 이전 집의 파랑색 중 더 작은 값에 현재 집에 빨강색 값을 더하여 저장하는 것이다.
이 과정을 N-1 번째 집까지 반복하고 그 집에 기록되어있는 R,G,B 중 최솟값을 구하면 된다.

라운드(?)가 진행된만큼 cost의 누적값을 유지해야 하는것이 포인트인 문제같다.★