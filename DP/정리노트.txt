1003.cs
n번째 피보나치수를 구할때 fibo(0), fibo(1)이 몇번이나 호출되는지 구하는 문제였다.
당연히 기본 재귀를 이용하면 시간초과가 뜨게된다.
고로 Memoization을 이용해서 즉 동적프로그래밍을 이용해야한다.

규칙을 찾아보면 fibo(n)에 대해서 fibo(1)호출 횟수는 fibo(n)과 같고 
fibo(0)호출 횟수는 fibo(n-1)의 값과 같다.

고로 기본 fibonacci 메소드를 구현한 후 위처럼 출력해주면된다.
                one = fibonacci(fibo);
                zero = fibonacci(fibo - 1);


9184.cs
문제에서 메소드가 주어져있으며, 해당 재귀형식 동적프로그래밍으로 바꿔주기만 하면 되는 문제다.
고로 값이 계산이 되어있는지 판별 후 되어있다면 바로 return, 되어있지않다면
계산 후 저장하고 return해주면 된다.


1904.cs
1과 00으로 만들 수 있는 모든 2진수의 갯수를 구하는 문제.
-> 규칙을 찾아보면 피보나치 수와 똑같은 결과가 나옴.



9461.cs
파도반 수열이 주어지는데, 해당 수열의 규칙을 찾아보면
N번째 파도반 수 = N-1번째 파도반 수 + N-5번째 파도반 수 라는 점화식을 찾을 수 있게 된다.
고로 1~5번째 수 까지는 직접 초기화를 해주고 6번째 수 부터 반복문을 돌면서
위 점화식으로 모든 파도반 수를 구해놓으면 되는 간단한 문제이다.




1149.cs
해당 문제는 쉽게 해결하지 못했다.
처음에는 백트래킹처럼 모든 경우의 수를 가지치기하며 따져보는 방식만이 떠올랐는데
해당 방식은 DP도 아닐뿐더러 시간초과가 우려되어 시도하지 않았다.
결국 여러 자료들을 참고하며 풀어냈다.

->>
인접한 집끼리는 같은 색깔로 칠할 수 없기 때문에 이전 집 페인트 값 중 현재 집에 칠할 색을 제외하고 minimum 값을 구한다.
그것과 현재 집에 칠하려 했던 색을 더하여 dp 배열에 저장한다. 
즉, 빨강색을 색칠하려한다면 이전 집의 초록색, 이전 집의 파랑색 중 더 작은 값에 현재 집에 빨강색 값을 더하여 저장하는 것이다.
이 과정을 N-1 번째 집까지 반복하고 그 집에 기록되어있는 R,G,B 중 최솟값을 구하면 된다.

라운드(?)가 진행된만큼 cost의 누적값을 유지해야 하는것이 포인트인 문제같다.★




1932.cs
피라미드 형식으로 이루어진 수의 집합에서 위에서부터 숫자를 대각선으로만 선택하며 내려와
구할 수 있는 최대값을 출력하는 문제였다.
너무도 단순하게, 가장 위에 존재하는 수 부터 자신의 왼쪽아래, 오른쪽아래 대각선의 수와 
자신을 더한 값이 해당 대각선의 원래 위치하던 값보다 큰 경우 값을 대체해주도록 반복하면 된다.

	      5					      
	     
	3	5

      2           1           6

(첫번째 수 5) : 5 + 3 이 3보다 크므로 8로 대체, 5 + 5가 5보다 크므로 10으로 대체

	      5
	     
	8	10

      2           1           6	

(두번째 수 8) : 8 + 2 가 2보다 크므로 10으로 대체, 8 + 1이 1보다 크므로 9로 대체 

	      5
	     
	8	10

      10          9           6	

(세번째 수 10) : 10 + 1이 9보다 크므로 11로 대체, 10 + 6이 6보다 크므로 16으로 대체

	      5
	     
	8	10

      2           11          16	

최종적으로 16이 최대값이 된다.

여기서 중요한점은 각 수 까지로 이동하는 최대값의 경우를 저장해가면서 진행한다는 점.★





2579.cs (중상)
3개의 연속된 계단을 밟지못하고, 한번에 1칸 혹은 2칸만 올라갈 수 있는것이 조건.

처음 아이디어 -> n번째 계단에 도착하려면 n-1번째 혹은 n-2번째 계단에 도착해야 하므로
n-1번, n-2번째 계단에 도착하는 최댓값과 n번째 계단값의 합을 비교하려 했다.
이대로만 진행하게되면, n-1번째에 도착한 경우를 비교할때 연속된 3개의 계단을
밟게되는 경우가 생길 수 있었다.

최종 아이디어
-> n번째 계단에 도착하기 위해서 n-1, n-2번째 계단을 밟아야 하기 때문에
Max( n-1번째 계단값 + n-3번째 계단까지의 최대값 + n번째 계단값,  n-2번째 계단까지의 최대값 + n번째 계단값)
위와 같은 식이 성립되어야만 한다.
그래야 3개의 연속된 계단을 밟게되는 경우를 배제할 수 있다.




1463.cs (상)
기존의 DP문제처럼 패턴을 찾아보려 했지만 보이지않았고, 3으로 나누는 것이 가장 수를 빠르게
작게 만들 수 있는 경우라 생각도 해보았지만 제시해준 10으로 진행해보면 바로 반례가 나오게되었다.
결국 여러 힌트를 참고해서 풀게되었는데 DP는 패턴을 찾고 점화식을 세워서 푼다! 라는 고정관념이 있어
문제를 쉽게 풀지 못한 것 같다. 물론 점화식을 세워서 푸는 것은 맞지만 너무 패턴을 찾는데만 집중하지
말고 넓게 생각할 줄 알아야 할 것 같다.

예시) 4의 경우
d[4를 1로 만드는 최소 횟수] = 
  (1) N-1을 하면 N=3이 되고, 다시 N/3을 하면 1이 된다. => 2번
  (2) N/2를 하면 N=2가 되고, 다시 N/2나 N-1을 하면 1이 된다. => 2번
  (3) N/3의 경우는 불가능하다.
결국 이 경우의 수 중에서 제일 작은 값인 2번이 된다.

즉 N을 최소 횟수로 1로 만드는 과정은 "주어진 수(N)에서 -1또는 /2 또는 /3을 통해 수를 최소 횟수로 
줄여나가 1까지 만든다"의 사고과정을 따른다. 
->>
주어진 수(N)을 1로 만드는 최소 횟수는 =  'N-1을 1로 만드는 최소 횟수 + 1번' 또는
 'N/2를 1로 만드는 최소 횟수 +1번' 또는 'N/3을 1로 만드는 최소 횟수 + 1번' 이 된다.
이를 식으로 표현하면 d[N을 1로 만드는 최소 횟수] = d[N-1을 1로 만드는 최소 횟수]
 + 1번 or d[N/2를 1로 만드는 최소 횟수] + 1번 or D[N/3을 1로 만드는 최소 횟수] + 1번이 된다.

//코드로 표현하자면 아래와 같다.

                // N값에 -1을 한 경우에 대해서 최소값을 dp로 구한다.
                dp[i] = dp[i - 1] + 1;

                // N값에 /2가 가능하다면 해당 경우에 대해서 최소값을 dp로 구한다.
                if (i % 2 == 0)
                {
                    dp[i] = Math.Min(dp[i], dp[i / 2] + 1);
                }

                // N값에 /3이 가능하다면 해당 경우에 대해서 최소값을 dp로 구한다.
                if (i % 3 == 0)
                {
                    dp[i] = Math.Min(dp[i], dp[i / 3] + 1);
                }

                //최종적으로 -1, /2, /3 각 결과중 가장 최소값이 저장되게 된다.





10844.cs (중)
인접한 모든 자리수가 1의 차이를 가져야하는 조건에서 n이 주어질때, n인 계단 수가 총 몇개인지 구하는 문제.
우선 DP같은 경우 메모이제이션을 이용해야하기 때문에, 어떤 부분이 중복계산 되는지 생각해보았다.
-> 1~9 까지 +1 -1 해보면서 진행하는 문제에서는 전혀 사용할 수 없었음.
-> 주어진 n마다 1~9로 시작하는 n자리수의 계단 수의 갯수를 메모이제이션에 이용할 수 있지 않을까 생각해보게됨.
<자릿수가 1씩 증가되므로, 이전에 계산했던 갯수를 이용 가능하기 때문임.>

먼저 1~9로 시작하는 계단 수를 n이 1, 2, 3일때 나열을 해보았다.

n = 1		n = 2		n = 3

1) 1		10, 12		101, 121, 123
2) 2		21, 23		210, 212, 232, 234
3) 3 		32, 34		321, 323, 343, 345
4) 4		43, 45		....
5) 5		54, 56
6) 6		65, 67
7) 7		76, 78
8) 8		87, 89
9) 9		98

n = 3일때 2로 시작하는 계단수의 경우 맨앞의수 2를 제외하면 10, 12, 32, 34로  n = 2일때의 1, 3으로 시작하는 계단 수의
합이라는 점을 찾아냈다.
이점을 메모이제이션을 통해서 DP로 문제를 해결할 수 있을 것 같았다.
하지만, 1, 9로 시작하는 경우에는 예외가 발생했다. -> 결국 해결하지 못함.

다시 수들을 자세히 살펴보니, 시작하는 수가 아니라 끝나는 수를 기준으로 봐야한다는것을 알 수 있었다.
0으로 끝나는 수는 -1을 뒤에 덧붙일 수 없으니 1만 덧붙여주고, 9로 끝나는 수는 10을 덧붙여 줄 수 없으니
8만 덧붙여준다면 위에서 생각했던 아이디어와는 달리 모든 경우를 해결 할 수 있었다.

고로 n이 1,2,3일때 0~9로 끝나는 계단 수의 갯수를 다시 나열하였고
dp[i, j] = (dp[i - 1, j - 1] + dp[i - 1, j + 1]) 와 같은 점화식을 얻어낼 수 있었다.

DP문제들은 항상 번뜩이는 아이디어를 떠올려야하는 점이 어려운 것 같다..

