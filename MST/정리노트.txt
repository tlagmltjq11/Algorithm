▶ 1717.cs
유니온 파인드를 c#으로 구현해보는 문제.
기존 내가 사용하던 Find() 함수를 사용했더니 왜인지 시간초과가 떴다.
오히려 재귀를 이용해야만 통과되었다. -> 난 반복문으로 풀었는데 어째서 더 늦는것인지 다시 풀어봐야겠다.

▶ 9372.cs ★★
가장 적은 종류의 비행기를 사용하겠다는 의미는 -> 간선의 수가 가장 적었으면 좋겠다는 의미이다.
이 말은 결국 신장트리를 만들어내면 된다는 의미이고 신장트리는 DFS, BFS를 통해서 거치게되는 모든 간선을 구하면된다.
하지만 답은 간선의 갯수를 물어보고 있기 때문에 허무하게도 노드의 수 - 1만 해주면 답이 나오게 된다.

▶ 1197.cs ★
유니온-파인드와 크루스칼 알고리즘을 이용해서 최소신장트리를 구해보는 문제이다.

▶ 4386.cs ★★
1197과 마찬가지로 MST를 구하는 문제인데 대신 좌표의 정보만 주고, 간선이나 가중치에 대한 정보는 일절 없었다.
그래서 정점에 대한 정보만 주어졌기에 프림 알고리즘을 사용해야 하나 싶었는데, 좌표의 최대 갯수가 100개 이하여서
직접 모든 좌표들간의 간선을 구한 후 해당 간선들의 리스트에 대해 크루스칼 알고리즘을 적용할 수 있었다.
만약 좌표의 범위가 컸다면, 모든 간선을 구하는 비용이 크기에 무조건 프림을 사용해야 했을 것이다.
<프림은 아직 익숙하지 않으니 연습이 필요하다.>

▶ 1774.cs
크루스칼을 통해서 MST를 구하는 문제이다.
다른 문제와 다른 조건은 이미 선택된 m개의 간선을 제공한다는 것이다.
해당 간선들은 입력받자마자 Union을 통해 간선이 선택되었음을 나타내주면 추후 모든 간선의 경우의 수에서
동일한 간선을 만나더라도 Union 처리가 되지 않을 것이다. 고로 m개의 간선 유니온처리를 했다면
일반적인 크루스칼 문제처럼 진행하면 된다.

▶ 2887.cs ★ 다시 이해하기. ★
크루스칼을 통해 MST를 구하는 문제이다.
하지만 정점좌표의 개수가 십만개까지여서 모든 간선을 구하자니 100억개의 메모리 공간이 필요하게 되어,
결국 메모리초과 혹은 시간초과로 이어지게 된다.
여기서 어떠한 방식으로 진행해야할지 막혔었는데 간선의 가중치를 구할때 x,y,z좌표 차이의 가장 최소값을 사용한다는 점을
이용해야 한다는 것을 알았다. 세 좌표 간의 차이 중 가장 작은값만 사용하면 되기 때문에, x, y, z 좌표를 따로 오름차순 정렬 후
x[i] , x[i+1]의 간선을 구해 간선 리스트에 추가해주고 크루스칼을 적용하면 된다. https://dev-jk.tistory.com/29

▶ 17472.cs ★★★ 삼성 기출문제
삼성 기출문제라길래 지레 겁먹었던 문제.. 섬과 바다로 이루어진 2차원 좌표내에서 모든 섬을 잇는 MST를 구하는 문제이다.
우선 2차원 맵을 봤을때 각 섬을 하나의 정점으로 보아야 한다고 생각했고, 그럴려면 구분을 할 수 있도록 구성해야 한다 생각했다.
그래서 DFS를 통해서 각 섬마다 고유의 섬번호를 부여했고, 2중 루프로 모든 좌표를 돌며 각 좌표마다 상,하,좌,우로 일직선으로
다리를 이어 유효한(길이가 2가 넘는) 다리 즉 모든 간선을 구해 리스트에 추가하도록 구현했다. 그 후 간선 리스트를 정렬한 후
일반 크루스칼과 같이 진행해서 풀어냈다. 이 문제의 해결책을 생각해내는데에는 몇분걸리지 않았지만 오히려 구현하는데
시간이 오래 걸렸던 문제이다. 아무튼 생각보다 쉽게 맞춰서 기분좋았던 문제.
