▶ 1920.cs
이진탐색을 직접 구현해 사용해보는 기본 문제이다. 익숙하던 재귀로 구현할까 했지만 효율성을 위해
반복문으로 처리했다.

▶ 10816.cs
간단한 이진탐색 문제인가 싶었지만, 배열내에 중복으로 존재하는 특정 값의 갯수를 모두 구해야 했다.
그렇기에 일반적인 이진탐색으로는 해결이 불가능했다. 처음 아이디어는 만약 현재 mid인덱스에 존재하는 값이
key와 같다면 배열을 이등분으로 나누지않고 재귀적으로 좌, 우 모두 이진탐색을 다시 돌리도록 하여
최종적으로 cnt값을 구해내려 했다. 물론 mid값이 key와 같지않고 크거나 작다면 일반 이진탐색처럼 진행한다.
이 방법을 구현한것이 ▶ 10816_test.cs 이다. 분할정복의 느낌도 나지만 어쨌든 결과는 정확하게 도출이 되었다.
하지만 재귀를 사용할 뿐만 아니라, 수의 갯수를 모두 세는데까지 함수의 호출이 너무 잦기 때문에 "시간초과" 가 뜨게 됐다.
그리하여 다른 방법을 찾아야만 했다. 두번째 방법은 만약 배열내에서 10을 찾는다고 할때 10의 시작 인덱스와
끝나는 인덱스를 알게되면 배열은 정렬된 상태기에 갯수를 손쉽게 두 인덱스의 차를 통해 구할 수 있다는 생각을 했다.
https://m.blog.naver.com/PostView.nhn?blogId=bestmaker0290&logNo=220820005454&proxyReferer=https:%2F%2Fwww.google.com%2F
해당 링크에서 구현을 참고받았다.

▶ 1654.cs
https://www.acmicpc.net/problem/1654 문제는 링크를 참조하자.
이진탐색을 통해서 최소 혹은 최대값을 찾아내는 테크닉 문제다.
랜선을 잘라내 동일한 길이의 랜선을 n개 이상 만드는 것이 목적인데 이때 가장 긴 길이로 잘라내어야 한다.
여기서 테크닉이 필요한데, 기존 이분탐색은 특정 배열내에서 특정 값을 찾는 것이지만 이 문제는
직접 범위를 설정하고 그 안에서 조건에 부합하는 값을 찾아내야 한다.
고로 랜선을 잘라낼 길이를 최소 : 1, 최대 : 랜선들 중 최댓값 으로 설정하고 해당 길이로 모든 랜선들을
잘라냈을때, n개 이상이 된다면 더 큰 값을 위해 left = mid + 1로 설정하고 이분탐색을 진행한다.
만약 n개 이하가 된다면 right = mid - 1로 설정하고 이분탐색을 진행한다.
최종적으로 조건에 부합하는 랜선의 최대길이를 찾아낼 수 있다.

▶ 2805.cs
1654.cs와 유사한 문제로 나무를 자를 최대 높이를 이분탐색으로 구하는 문제이다.
최대값과 최소값을 구하는데 이분탐색을 이용해서 시간복잡도를 줄일 수 있다는 것을 
일깨워주는 문제들인 것 같다.

▶ 2110.cs
이 문제 역시 2805.cs와 유사한 문제로 가장 인접한 공유기간의 최대 가능거리를 구하는 문제였다.
최대 가능거리를 이진탐색을 이용해서 최댓값을 구하면 되는 문제인데 각 단계에서 해당 최대거리를
실제로 적용시킬 수 있는지 판단하는것이 중점인 문제이다.
★ 중요 포인트는 현재 이진탐색 단계에서 mid값이 3이라면 가장 인접한 공유기의 거리가 3이어야 하기 때문에 ★
다른 모든 공유기간의 거리는 3이상이어야 한다. 고로 집들을 정렬한 후 처음 집부터 시작해서 (가장 멀게 해야하므로 첫 집 포함)
공유기의 거리가 3이상이라면 카운트해주며 판단해주면 되는 문제이다.

▶ 1300.cs
https://devowen.com/265
http://wookje.dance/2017/02/20/boj-1300-K%EB%B2%88%EC%A7%B8-%EC%88%98/

