▶ 1920.cs
이진탐색을 직접 구현해 사용해보는 기본 문제이다. 익숙하던 재귀로 구현할까 했지만 효율성을 위해
반복문으로 처리했다.

▶ 10816.cs
간단한 이진탐색 문제인가 싶었지만, 배열내에 중복으로 존재하는 특정 값의 갯수를 모두 구해야 했다.
그렇기에 일반적인 이진탐색으로는 해결이 불가능했다. 처음 아이디어는 만약 현재 mid인덱스에 존재하는 값이
key와 같다면 배열을 이등분으로 나누지않고 재귀적으로 좌, 우 모두 이진탐색을 다시 돌리도록 하여
최종적으로 cnt값을 구해내려 했다. 물론 mid값이 key와 같지않고 크거나 작다면 일반 이진탐색처럼 진행한다.
이 방법을 구현한것이 ▶ 10816_test.cs 이다. 분할정복의 느낌도 나지만 어쨌든 결과는 정확하게 도출이 되었다.
하지만 재귀를 사용할 뿐만 아니라, 수의 갯수를 모두 세는데까지 함수의 호출이 너무 잦기 때문에 "시간초과" 가 뜨게 됐다.
그리하여 다른 방법을 찾아야만 했다. 두번째 방법은 만약 배열내에서 10을 찾는다고 할때 10의 시작 인덱스와
끝나는 인덱스를 알게되면 배열은 정렬된 상태기에 갯수를 손쉽게 두 인덱스의 차를 통해 구할 수 있다는 생각을 했다.
https://m.blog.naver.com/PostView.nhn?blogId=bestmaker0290&logNo=220820005454&proxyReferer=https:%2F%2Fwww.google.com%2F
해당 링크에서 구현을 참고받았다.

▶ 1654.cs
https://www.acmicpc.net/problem/1654 문제는 링크를 참조하자.
이진탐색을 통해서 최소 혹은 최대값을 찾아내는 테크닉 문제다.
랜선을 잘라내 동일한 길이의 랜선을 n개 이상 만드는 것이 목적인데 이때 가장 긴 길이로 잘라내어야 한다.
여기서 테크닉이 필요한데, 기존 이분탐색은 특정 배열내에서 특정 값을 찾는 것이지만 이 문제는
직접 범위를 설정하고 그 안에서 조건에 부합하는 값을 찾아내야 한다.
고로 랜선을 잘라낼 길이를 최소 : 1, 최대 : 랜선들 중 최댓값 으로 설정하고 해당 길이로 모든 랜선들을
잘라냈을때, n개 이상이 된다면 더 큰 값을 위해 left = mid + 1로 설정하고 이분탐색을 진행한다.
만약 n개 이하가 된다면 right = mid - 1로 설정하고 이분탐색을 진행한다.
최종적으로 조건에 부합하는 랜선의 최대길이를 찾아낼 수 있다.