▶ 1260.cs
그래프를 c#으로 직접 구현하고 BFS, DFS의 구현을 복기하는데 도움을 주는 문제이다.
기존 c언어로 그래프를 구현할때에는 인접행렬 혹은 연결리스트를 통한 인접리스트로 구현했는데
c#에서는 포인터 연산자가 없다보니 전부 코드를 뜯어고쳐야 했다. 여기까지는 문제가 없었지만
인접리스트를 배열로 관리하는것이 너무 비효율적이고 문제에서 요구하는 작은 정점부터 방문! 이라는 조건을
충족하기에도 매우 비효율적인 구조를 갖고있었다. 그리하여 List를 이용하는 그래프로 재구현하였고
해당 방식이 메모리 관리 측면에서 더 효율적인 방법이라 생각되었다.

▶ 2606.cs
특정 정점과 경로가 존재하는 모든 정점들의 개수를 구하면 되는 문제였다.
고로 DFS, BFS 어느것으로 풀어도 상관없다. 정점에 방문할때마다 카운트만 올려주면되는 단순한 문제이다.

▶ 2667.cs
0과 1로 이루어진 행렬을 차례대로 순회하면서 1값을 갖고있으면서 방문된적이 없다면 해당 숫자는 1개 혹은 그 이상으로
이루어진 단지이게 된다. 고로 해당 정점부터 DFS를 수행해서 해당 단지내에 속하는 모든 정점의 갯수를 세주면 되는 문제이다.
단 인접한 정점들을 체크할때 기존과 다르게 인접행렬 혹은 인접리스트 방식이 아닌 상하좌우로 체크해야 하는 점을
유의하면 된다.

▶ 1012.cs
2667과 동일한 문제로 0과 1로 이루어진 행렬내에서 인접해있는 1들의 그룹 수를 세는 문제이다.
순회하면서 1을 만나게되면 DFS, BFS를 통해 해당 그룹을 모두 0으로 바꾸어주고 그룹의 수를 +1 해주면 되는 
간단한 문제이다.

▶ 2178.cs
가중치가 없는 그래프내에서 두 정점간 최단거리를 구하는 문제이다.
가중치가 없기 때문에 BFS를 이용해서 간단하게 이동거리를 누적해가며 정답을 도출할 수 있다.
BFS는 자신과 바로 연결되어있는 노드를 큐에 넣으며, 이러한 큐는 FIFO에 따라 먼저 들어온 것을 처리하므로
이 두개의 특성이 결합되어 시작위치로부터 간선의 수가 작은 곳 부터 먼저 처리되게 된다.
고로 BFS를 통해서 최단경로 및 거리를 구할 수 있는 것이다.
<그냥 가까운곳부터 처리되니 결국 가장먼저 도착하는 경우가 최단거리인 경우라는 것>

▶ 7576.cs
맨처음에는 분명히 인접한 토마토들이 익기 때문에 BFS문제라는 것은 알았지만 그 외에 진도가 나가질 않았다.
잠시 생각해보니 행렬에서 1값인 즉 익은 토마토들의 좌표를 전부 파악한 후 해당 좌표들로 부터 동시에
BFS를 처리해주면 될 것 같다는 생각이 들었다. 그리하여 익은 토마토들의 좌표를 모두 큐에 넣고
큐에 존재하는 좌표들에 대해서 동시에 BFS를 진행해주었다. 한 사이클마다 동시에 진행되어야 하는 요소들의
갯수를 세고 해당 갯수만큼 BFS를 진행한다면 Day + 1을 해주었는데 이 방식 말고 행렬 자체에 일수를 누적시켜
진행하는 방식이 더 깔끔한 것 같다.

▶ 7569.cs
7576.cs 의 3차원 버전 문제이다. 3차원 즉 상, 하에 대한 인덱스 처리를 추가해주면 된다.
이 문제에서는 7576과 다르게 행렬 자체에 일수를 누적시켜서 BFS가 끝난 후 최댓값을 찾아서
출력해주는 방식으로 좀 더 깔끔하게 해결했다.

▶ 1697.cs
정답률이 굉장히 낮아서 겁먹었지만 굉장히 쉽게 풀어낸 문제이다.
n점에서 k점까지 최단거리로 이동해야하는데 한 사이클마다 -1 ,+1, x 2만큼 씩 이동할 수 있었다.
해당 문제를 아래와 같이 트리처럼 생각해서 BFS로 순회하며 k에 도착하는 최단거리를 구하면 될 것 같았다.
	5
4	6	10

소요되는 시간은 KeyValuePair로 각자 누적된 시간값을 갖고있게 했으며 주의해야 할 점은 
5 -> 4 -> 5 혹은 5 -> 6, 4 -> 5 -> 6 처럼 똑같은 값을 계속해서 큐에 넣어주게 되면 메모리초과가 뜨게되므로
꼭 visitied[] 배열을 사용해주어야 한다.

▶ 2206.cs ★★★★★
기본적인 BFS 문제에서 벽을 한번만 부술 수 있단는 조건만 추가된 것인데 쉽사리 풀어내지 못한 문제이다.
블로그에서 해답을보고 직접 손으로 큐의 내용요소들을 그려가며 이해는 완료했지만 쉽사리 글로 풀어낼 정도로
이해한것은 아니라 추후에 꼭 다시 풀어봐야 겠다.
대충 얘기하자면 벽을 뚫었는지 안뚫었는지에 대한 값을 각 큐의 요소들이 누적해가며 들고가야 한다는 점이다.
그렇게되면 이미한번 최단경로의 길이 아닌 벽을 뚫고온 경로는 우회하기 때문에 도태되며, 제대로된 벽을 뚫고온
경로가 가장먼저 도착좌표에 도달하게되므로 최단경로를 구할 수 있게 된다.
벽을 뚫었는지 여부를 확인하기 위해서 visited를  3차원 배열을 이용해야 한다는 점을 유의하자.
이미 방문한 정점이더라도, 벽을 부수고 왔는지, 벽을 부수지 않고 왔는지에 따라 서로 다른 경로가 되기 때문이다.
-> 벽을 뚫고가는 경우의 방문여부를 따로 체크해줘야 하는 이유는 해당 좌표까지 오는데 만약 다른 벽을 뚫고온 경로가
-> 이미 방문했다면 해당 경로가 더 빠른 경로라는 소리이기 때문에 나는 다른 경로를 통해서 이동해야 한다는 것이다.★
-> 원래대로라면 아직 방문하지 않은 정점이기에 방문할 수 있어야 하겠지만, BFS 속 수많은 경로들 중 이미 한 벽을 뚫고
-> 해당 좌표를 지나가버린 즉 현재 경로보다 훨씬 빨랐던 경로가 존재하기 때문에 해당 좌표까지의 최단거리가 망가지지 않도록
-> 벽을 뚫고 지나온 경로들의 경우 방문을 막아주어야 한다는 것이다. 그렇기 때문에 벽을 뚫고온 경로들의 방문여부를 따로
-> 체크해주어야 하는 것이다.
https://kscodebase.tistory.com/66 참고

▶ 7562.cs
체스에서의 나이트를 이동해 원하는 목적지 까지 가는 기본적인 BFS 최단거리 찾기 문제이다. 
단 visited를 체크해주지 않을 경우 시간초과!

▶ 1707.cs ★
이분그래프란 그래프내 정점들을 두 그룹으로 나눌 수 있는 그래프를 의미하는데 여기서 같은 그룹에 속한
정점들끼리는 인접하면 안된다는 것이 그 정의이다.
처음 이 문제를 접했을때 BFS를 통해서 인접한 정점들을 방문할때 자신과 반대의 색으로 칠해서 그룹을 나누어주고
만약 이미 다른 노드에 의해서 ★★방문된 노드라고 하더라도 자신과 인접해있으면 색이 자신과 반대인지 체크★★해주어야 한다고
생각했다. 그래서 이대로 코드를 짰더니 "틀렸습니다"가 떴다. 도무지 틀린 부분을 찾을 수 없어서 블로그를 참고해보니
비연결그래프를 생각했어야 하는 것이었다.. 그래서 main 함수에서 BFS를 돌릴때 이전 BFS에 의해서 아직까지도 방문되지
않은 정점이있다면 해당 정점을 시작 노드로 지정하고 다시 BFS를 돌려주어야 했다.
결론적으로 비연결그래프라면 왼쪽 그래프, 오른쪽 그래프 모두 이분 그래프여야 YES를 출력해주어야 했던 것이다.
https://toastfactory.tistory.com/115

▶ 1389.cs
BFS를 통해 한 정점으로부터 모든 정점까지의 최단경로를 구하는 문제.
-> 물론 다익스트라 or 플로이드 알고리즘으로 풀어도 좋지만 가중치가 없었기 때문에 BFS로 풀었다.

▶ 16928.cs ★★★
뱀과 사다리 게임에서 도착점에 도착하는 최소 횟수를 구하는 문제.
처음엔 뱀과 사다리의 모든 경우의 수를 DFS로 따져봐야 하나 생각했지만,
BFS를 통해서 최단경로를 구하는 문제나 다름 없다고 판단해서 BFS로
이동하는 경우를 따져가며 구함.

▶ 11403.cs
BFS를 통해서 경로가 존재하는지 구하는 문제.

▶ 10026.cs
DFS로 구역 나누는 문제. 좀 더 간결한 코드로 최적화 해야할듯 하다.

▶ tttt.cs
NHN 사전테스트 : 행렬의 영역 문제
행렬에 1로 이루어진 영역의 갯수와 각 영역의 크기를 구하는 문제로
DFS를 통해 순회하면 쉽게 풀 수 있다.

▶ 9019.cs ★
D, S, L, R 연산을 이용해서 타겟 십진수를 만들어내는 문제다.
각 경우의 수 마다 각각의 연산을 이용한 경우를 모두 따져가며 가장 빠르게 타겟 넘버를 만들어내는 경우를
출력하면 된다. 즉 BFS로 풀어내는 문제다.
처음엔 시간초과가 우려되어 최적화된 코드를 생각하고 있었는데 너무 어려워 블로그를 참고해보니
그냥 모든 경우의 수를 따져도 시간초과가 나지않는 쉬운 문제라는 것을 알 수 있었다.
