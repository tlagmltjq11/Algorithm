▶ 입국심사.cs (이진탐색)
처음에는 미숙하게도 시간을 세는 cnt 변수를 하나 이용해 모든 심사관 앞에서 기다려야 할 시간을 구하고
해당 시간들을 정렬하여 가장 작은 값을 찾아내려 했다. 하지만 이런 방식은 logn을 n번 해야하니 결국 nlogn이 걸려
시간초과가 날 것이라는 것을 깨달았다. 그리하여 단 한번의 이분탐색 루프를 통해 값을 찾아야 했다. 

이진 탐색으로 접근하게 되면 어떤 값을 기준으로 범위를 좁혀 나가면서 답을 찾아내야 할지 생각한다.
문제에서는 모든 사람이 심사를 받는데 걸리는 시간의 최솟값 을 요구 했으니 시간 을 기준으로 범위를 잡아본다.
start는 가장 최솟값이므로, 기다리는 사람 수가 1이고 심사 시간이 1분만 걸리는 심사관 밖에 없을 때를 생각해본다면 1이 나온다.
end 역시 시간을 기준으로 생각했을 때, 심사 시간이 가장 오래 걸리는 사람에게 n명 모두 갔을 때이다.
 => times[times.size()-1] * n

start와 end 범위를 잡았으니 이진 탐색을 시작한다.
좀 헷갈렸던 부분이 cnt 라는 변수 인데, ★★이 cnt 는 시간이 아닌 mid 시간동안 심사 처리할 수 있는 모든 사람 수를 의미한다.★★
그래야 이 cnt 값으로 최소 시간을 찾을 수 있기 때문이다.
그래서 cnt(mid 시간 동안 심사 처리할 수 있는 모든 사람 수) 가 기존 n(기다리는 사람 수) 보다 작으면
 해당 문제 조건을 만족하지 못하기 때문에 최솟값인 start 를 mid +1로 갱신해서 다시 탐색을 한다.
그리고 cnt가 만약 n명 이상을 충족했을 때는, end 값을 다시 갱신해준다 (end = mid - 1)
9번 조건을 만족했을 때, 탐색하는 기준 시간(mid)이 최대값(end) 보다 작으면 문제 조건을 충족하기 때문에
★mid 값이 최소 시간이 될 수 있다는 의미다. 따라서 answer에 계속 갱신해준다.★
이를 while 문의 조건인 start <= end 일 때까지 계속 반복하다보면 모든 사람이 심사를 받는데 걸리는 시간의 최솟값이 나온다.

tip.
해당 문제를 풀때 end = times[times.size()-1] * n; 로 구하는데 여기서 times[times.size()-1]와 n은 모두 int 형이기 때문에
결과값도 int로 반환되어 overflow가 일어난다. 고로 둘 다 (long)으로 명시적 형변환을 해주어야 한다.
-> end  = (long)times[times.size()-1] * (long)n;

▶ 네트워크.cs (DFS, BFS 그래프) ★★★
인접행렬로 주어진 그래프내에서 연결그래프가 총 몇개 존재하는지 구하는 문제였다.
내 풀이 : 우선 start를 정하고 해당 start로 부터 DFS를 한바퀴 돌리게되면 start와 연결되어있는
모든 정점들은 방문이 될 것이다. 그 이후에 아직 방문되지않은 정점이 존재한다는 것은
해당 정점은 새로운 연결그래프로서 존재한다는 의미이므로 해당 정점으로부터 다시 DFS를 돌린다.
이후는 위와 같이 반복한다. 결국 ★몇번 DFS를 호출하느냐가 그래프의 갯수이다.★

▶ 단어 변환.cs (DFS, BFS 그래프) ★★★
문제 자체는 굉장히 쉽게 풀어낼 수 있었다. 그저 BFS를 통한 최단길이를 찾으면 되는 문제였다.
하지만 단어를 변환해가는 과정을 그래프의 개념과 연관짓는 것, ★즉 한글자만 다를때 변환이 가능한 경우를
길이 존재하느냐 존재하지않느냐라는 개념으로 연관짓는것이 쉽지않았고★ 풀어보고나니 굉장히 참신한 문제라는 생각이 들었다.
여지껏 BFS 문제라하면 문제에 대놓고 그래프 형식이나 행렬이 주어지곤 했는데 전혀 같은 부류의 문제같아 보이지 않았는데
BFS로 연관지어 풀 수 있다는 것에 재미를 느낄 수 있었다.