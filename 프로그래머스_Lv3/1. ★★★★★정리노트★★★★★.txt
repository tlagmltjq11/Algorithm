▶ 가장 긴 팰린드롬.cs (연습문제)
처음에는 팰린드롬 체크를 Stack을 이용하고 substring을 이용해서 팰린드롬 메서드에 넘겨주었더니
TC 1개에서 시간초과가 떴다. 그래서 팰린드롬 체크와 부분문자열을 모두 index로만 이용해서 풀었더니
해결되었다. 알고리즘은 문자열의 최대길이부터 -1 씩 해보면서 해당 길이의 부분문자열 팰린드롬이 문자열내에
존재하는지 모두 검사해보면 된다. 가장 먼저 찾게되는 길이가 최대의 길이가 된다.

▶ N-Queen.cs (연습문제)
백트래킹을 사용해 체스판에 퀸을 놓는 간단한 문제.

▶ 기지국 설치.cs (연습문제)
기지국을 최소 갯수로 설치하는 문제.
이미 설치되어있는 기지국들을 기준으로 사이사이마다 몇칸이 띄워져있는지 판단하고
해당 칸에 기지국이 몇개 필요한지 나누기로 구하면되는 간단한 문제이다.
단 매개변수로 넘어온 stations[]를 기준으로 사이 간격을 체크해야한다는 아이디어를 떠올릴 줄 알아야한다.
배열을 만들고 직접 설치된곳을 체크하고 설치되지않은곳을 일일이 세는 것은 비효율적이기 때문이다.

▶ 멀리 뛰기.cs (연습문제)
한번에 1칸 혹은 2칸만 이동할 수 있고 가야할 총 거리가 주어졌을 때 해당 거리를 갈 수 있는 모든 경우의 수를 구하는 문제
처음에는 당연히 순열과 조합을 이용해서 푸는 문제일 줄 알았으나, 거리가 1일때 2일때 3일때 4일때... 결과값을 보아하니
규칙이 존재하는 것을 발견했다. 결국 DP 문제라는 것을 파악하고 점화식을 세워 풀어냈다.
(3레벨은 아닌 것 같다.)

▶ 숫자 게임.cs (연습문제)
이미 숫자와 순서가 공개된 A팀에 대해서 B팀이 가장많이 승리하는 경우를 구하는 문제이다.
B팀의 순서를 구하는 것이 아니라 최대 승리 수를 구하는 것이 문제이기 때문에
단순히 두 팀의 숫자를 오름차순으로 정렬하고 B팀의 가장 큰 숫자를 이용해서 A팀의 숫자 중
가장 큰 이길 수 있는 숫자를 하나씩 제거해 나가면 되는 문제이다.
index를 이용해서 풀어야만 효율성을 통과할 수 있다.

▶ 야근 지수.cs (연습문제)
주어진 n을 갖고 현재 남은 작업량 시간들의 제곱 합을 최대한 작은값으로 만드는 문제
-> 그저 최대값에서 -1씩 해주면 전체 값들이 평등해지며 제곱합 값이 작아질 것으로 예상했다.
-> 우선순위 큐가 사용하기 적합한 자료구조라 생각해 사용했다.

▶ 하노이의 탑.cs (연습문제) ★★★
재귀적으로 풀 것이라는 예상은 했지만 생각보다 규칙을 찾아내기 힘들어 아래 블로그를 참고했다. (굉장히 설명 잘해놓음)
나중에 한번 더 풀어봐야겠다.
https://shoark7.github.io/programming/algorithm/tower-of-hanoi

▶ 섬 연결하기.cs (그리디) ★
MST를 구하는 문제 -> 크루스칼 및 유니온 파인드 알고리즘을 적용해서 풀어냈다.

▶ 입국심사.cs (이진탐색)
처음에는 미숙하게도 시간을 세는 cnt 변수를 하나 이용해 모든 심사관 앞에서 기다려야 할 시간을 구하고
해당 시간들을 정렬하여 가장 작은 값을 찾아내려 했다. 하지만 이런 방식은 logn을 n번 해야하니 결국 nlogn이 걸려
시간초과가 날 것이라는 것을 깨달았다. 그리하여 단 한번의 이분탐색 루프를 통해 값을 찾아야 했다. 

이진 탐색으로 접근하게 되면 어떤 값을 기준으로 범위를 좁혀 나가면서 답을 찾아내야 할지 생각한다.
문제에서는 모든 사람이 심사를 받는데 걸리는 시간의 최솟값 을 요구 했으니 시간 을 기준으로 범위를 잡아본다.
start는 가장 최솟값이므로, 기다리는 사람 수가 1이고 심사 시간이 1분만 걸리는 심사관 밖에 없을 때를 생각해본다면 1이 나온다.
end 역시 시간을 기준으로 생각했을 때, 심사 시간이 가장 오래 걸리는 사람에게 n명 모두 갔을 때이다.
 => times[times.size()-1] * n

start와 end 범위를 잡았으니 이진 탐색을 시작한다.
좀 헷갈렸던 부분이 cnt 라는 변수 인데, ★이 cnt 는 시간이 아닌 mid 시간동안 심사 처리할 수 있는 모든 사람 수를 의미한다.★
그래야 이 cnt 값으로 최소 시간을 찾을 수 있기 때문이다.
그래서 cnt(mid 시간 동안 심사 처리할 수 있는 모든 사람 수) 가 기존 n(기다리는 사람 수) 보다 작으면
 해당 문제 조건을 만족하지 못하기 때문에 최솟값인 start 를 mid +1로 갱신해서 다시 탐색을 한다.
그리고 cnt가 만약 n명 이상을 충족했을 때는, end 값을 다시 갱신해준다 (end = mid - 1)
9번 조건을 만족했을 때, 탐색하는 기준 시간(mid)이 최대값(end) 보다 작으면 문제 조건을 충족하기 때문에
★mid 값이 최소 시간이 될 수 있다는 의미다. 따라서 answer에 계속 갱신해준다.★
이를 while 문의 조건인 start <= end 일 때까지 계속 반복하다보면 모든 사람이 심사를 받는데 걸리는 시간의 최솟값이 나온다.

tip.
해당 문제를 풀때 end = times[times.size()-1] * n; 로 구하는데 여기서 times[times.size()-1]와 n은 모두 int 형이기 때문에
결과값도 int로 반환되어 overflow가 일어난다. 고로 둘 다 (long)으로 명시적 형변환을 해주어야 한다.
-> end  = (long)times[times.size()-1] * (long)n;

▶ 네트워크.cs (DFS, BFS 그래프) ★★★
인접행렬로 주어진 그래프내에서 연결그래프가 총 몇개 존재하는지 구하는 문제였다.
내 풀이 : 우선 start를 정하고 해당 start로 부터 DFS를 한바퀴 돌리게되면 start와 연결되어있는
모든 정점들은 방문이 될 것이다. 그 이후에 아직 방문되지않은 정점이 존재한다는 것은
해당 정점은 새로운 연결그래프로서 존재한다는 의미이므로 해당 정점으로부터 다시 DFS를 돌린다.
이후는 위와 같이 반복한다. 결국 ★몇번 DFS를 호출하느냐가 그래프의 갯수이다.★

▶ 단어 변환.cs (DFS, BFS 그래프) ★★★
문제 자체는 굉장히 쉽게 풀어낼 수 있었다. 그저 BFS를 통한 최단길이를 찾으면 되는 문제였다.
하지만 단어를 변환해가는 과정을 그래프의 개념과 연관짓는 것, ★즉 한글자만 다를때 변환이 가능한 경우를
길이 존재하느냐 존재하지않느냐라는 개념으로 연관짓는것이 쉽지않았고★ 풀어보고나니 굉장히 참신한 문제라는 생각이 들었다.
여지껏 BFS 문제라하면 문제에 대놓고 그래프 형식이나 행렬이 주어지곤 했는데 전혀 같은 부류의 문제같아 보이지 않았는데
BFS로 연관지어 풀 수 있다는 것에 재미를 느낄 수 있었다.

▶ 모두 0으로 만들기.cs (DFS, 트리) ★★
트리 내에 존재하는 모든 노드의 가중치를 0으로 만드는 문제이다.
DFS문제라는 것은 단박에 알아차렸지만, 자꾸 top-down 방식으로만 생각하다보니 잘 풀리지 않았다.
이후 리프노드까지 도달했다가 위로 올라오면서 0으로 만들어가는 방식이 정답이란것을 알아차리는데 까지
시간이 꽤 걸렸던 것 같다. 아무튼 리프노드에서 위로 올라오며 자신의 노드를 0으로 만들고 해당 횟수와 값을
부모노드에게 전해줘야한다. 해당 부모노드는 자식노드로부터 받은 값을 자신에게 더하고 횟수도 더해주어야 한다.
최종적으로 루트노드에 돌아왔을 때 루트노드가 0이 되어야지만 값이 존재하게 되는 것.

▶ 가장 먼 노드.cs (BFS 그래프)
출발 노드로부터 가장 먼 노드의 갯수가 몇개인지 즉 가장 먼 길이가 같다면 그 노드의 갯수가 몇인지 구하는 문제였다.
단순히 최단경로를 구하기 위해 BFS를 사용했고, 각 노드에 도착할때마다 출발지점으로부터 몇번의 간선을 지나쳤는지
저장하여 해당 값을 현재의 가장 먼 길이와 비교하며 업데이트해주었다.
최종적으로 모든 노드를 순회하고났을때 저장되어있는 가장 먼 길이와 갯수를 출력해주면 된다.

▶ 순위.cs (그래프, 플로이드 와샬 알고리즘) ★★★
(처음에는 플로이드 와샬에 관해 떠올리지 못해서 블로그를 참고했다.)
복싱선수간 승패결과를 단일방향그래프로 나타내고 순위가 확정된 선수의 수를 반환하는 문제였다.

★순위가 확정되려면 나머지 모든 선수와의 경기결과를 알 수 있어야 한다는 점이 중요하다.★
-> 더불어 a가 b를 이기고 b가 c를 이기면 a는 c를 이긴다는 점!! 이 점을 이용해 플로이드 와샬 알고리즘을 적용한다.★★

최종적으로 승패결과들을 모두 그래프에 적용시키고나서 각 선수마다 모든 선수와의 경기결과를 갖고있는지 판별하면 된다.

▶ 디스크 컨트롤러.cs (힙, SJF 알고리즘) ★★
프로세스 스케줄링 알고리즘 중 SJF(비선점) 알고리즘을 구현하는 문제다.
현재 작업중인 프로세스의 종료 이전에 요청된 작업들 중 가장 작업시간이 짧은 작업을 선택하도록 힙을 구현하여
풀 수도 있지만, 단순하게 리스트를 정렬하여 풀어낼 수 있는 문제여서 힙을 구현하지는 않았다.
모든 작업들을 1. 요청 시간이 빠른 순서 2. 요청 시간이 같다면 작업시간이 짧은 순서로 정렬 한 후
현재 curEnd 시간 이전에 요청된 작업들을 찾고 그 중 작업시간이 가장 짧은 것을 수행시키는 방식으로
또한 수행 후 curEnd를 적절히 업데이트 시켜주는 방식으로 풀어낼 수 있다.

▶ 이중우선순위큐.cs (힙 - 이중 우선순위 큐) ★
https://ansohxxn.github.io/programmers/kit14/

맥스힙, 민힙 2개의 힙을 동시에 운영하면서 문제를 풀어나가면 된다.
다만 Delete 연산 시에 두 힙에 존재하는 같은 숫자를 모두 제거해주거나 -> (배열로 구현한 heap은 복잡해짐)★
(애초에 우선순위큐를 제공하는 언어는 정말 손쉽게 두 큐의 같은 숫자를 제거해주면서 풀어낼 수 있음.★★)
혹은 하나의 힙에 대해서만 삭제한 후 두 힙의 최상단값을 비교해가면서 풀어낼 수 있다.

▶ 베스트앨범.cs (해시) ★★
해시 문제인 만큼 최대한 해시, 딕셔너리를 사용하려고 노력했다.
장르의 이름을 키로 사용하며, value에는 해당 장르에 속한 모든 노래의 고유번호와 플레이 횟수를 원소로 갖는 리스트를 할당했다.
그 후 각 리스트들을 문제에서 제시한 조건대로 정렬해주었다.
-> 이후에는  List<KeyValuePair<string, int>> sortList를 선언하여 key를 장르의 이름으로 사용하고,
 value는 장르에 속한 곡들의 총 플레이횟수를 할당했다. 해당 리스트를 총 플레이 횟수로 정렬하게되면
어떠한 장르의 순서대로 2곡씩 뽑아야하는지 알 수 있게된다.
고로 해당 리스트의 원소 순서대로 각 장르이름을 dict의 key로 사용해 곡들의 리스트를 불러내고
해당 리스트에서 정렬되어있는 순서대로 최대 2곡씩 뽑아서 추가하면 정답이 나오게 된다.

▶ 여행경로.cs (DFS, BFS 그래프) ★★★★
문제에서 주어지는 설명과 TC가 너무 부실하다고 느꼈고, 역시나 문제를 제대로 이해하지 못한 탓에
코드를 여러번 갈아 엎었다.
ICN 부터 출발하여 모든 경로를 돌아야하는 문제이다. 알파벳 순으로 이동하라고는 했지만 알파벳 순으로 이동했다가
모든 경로를 돌 수 없는 경우가 많이 생긴다. 고로 알파벳 순으로 정렬은 하되, 해당 알파벳 순으로 경로를 시작한다고 해서
무조건 원하는 경로를 얻어낼 수는 없다는 의미이다. 고로 해당 경로로 출발했을 때 원하는 답을 얻을 수 있는지 체크해보고
얻을 수 없다면, 알파벳 순이 느리더라도 다음번 경로를 통해 다시 시작해보아야 한다.
-> ★★ DFS를 재귀호출 할 때 반환값으로 bool을 넘겨주는 방식으로 구현하는데 해당 방식으로 하면 꽤나 깔끔한 코드 작성이 가능하다.
https://ansohxxn.github.io/programmers/kit30/ 참고함.

▶ 스티커 모으기(2).cs (DP) ★★★
역시나 DP 문제는 어렵고 알아차리기 힘들다.
처음 풀이는 양옆의 값이 최소가 되는 경우 스티커를 뽑는 것으로 풀었더니
절반정도만 통과가 되었다. 그래서 다른 풀이를 참고했더니 DP 문제였다.
https://ansohxxn.github.io/programmers/116/

혹시 DP 문제는 아닐까 하고 의심 해야 하는 경우
전에 이미 구해서 저장해놓은 값들을 바탕으로 현재의 값을 구하는 점화식을 세울 수 있을 때
최대값, 최소값 같은 최적해를 구해야 할 때
모든 원소들마다 그때까지 선택한 최적해를 구할 수 있을 때
입력 크기가 엄청 클 때

▶ 풍선 터트리기.cs (DP or two pointer) ★★★★
어려웠던 문제.
최후까지 남을 수 있는 풍선의 갯수를 리턴하는 문제이다.
조건은 임의의 두 풍선을 선택했을 때, 단 한번만 더 작은 수를 가진 풍선을 터트릴 수 있다는 것.
-> 해당 조건을 필두로 재귀를 돌려보려했으나 배열의 최대 수가 너무 커서 포기했다.

접근법만 찾아보니 임의의 풍선을 기준으로 좌측, 우측의 최솟값을 구해 풀어나가야 한다는 것을 배웠다.
처음에는 O(n^2) 방식을 떠올렸으나 해당 방식은 시간초과가 난다고 하길래 DP를 이용했다.
좌측에서부터 최소값 우측에서부터 최소값을 DP를 이용해 구한다. -> (2n)
각 풍선을 순회하며 해당 풍선 기준 좌측 최소값 우측 최소값 둘 중 하나라도 현재 풍선의 값보다 크다면 최후까지
남을 수 있다는 것 -> (n)
최종 (3n)에 풀 수 있다.

가장 중요한 핵심 아이디어는 임의의 풍선 기준 좌측 최소값, 우측 최소값이 모두 해당 풍선보다 작은 값을 갖고있다면
주어진 조건에서 단 한번만 더 작은 수를 터트릴 수 있다고 했으니 언젠가 밀려서 다가올 해당 두 풍선을 모두 터트릴 수 없기에
현재 풍선은 최종까지 남을 수 없다는 것!!★★★

▶ 다단계 칫솔 판매.cs (Recursive or DFS) ★
문제가 굉장히 길고 복잡해보이지만 풀이는 굉장히 간단한 문제다.
처음에 그림 설명과 함께 문제를 읽었을 때 트리를 구현해서 DFS를 호출해 return값으로 돈계산을 해야 하나
생각했는데 매개변수를 잘보니 굳이 트리를 구성하지 않고도 부모노드를 찾아갈 수 있다는 것을 파악했다.
빠르게 찾기 위해 Dictionary 자료구조를 이용해 자식-부모 관계를 만들었고 직원-돈 관계를 만들었다.
seller 즉 칫솔을 판매한 이력이있는 직원마다 재귀를 호출해주면 자신이 판매한 총 수익에서 10%를 떼고 더해준 후
해당 10%를 자신의 부모노드에게 보내주는 재귀를 호출해주면 해결되는 문제이다.

▶ 110 옮기기.cs (stack) ★★
문자열 내에서 "110"을 옮겨 사전순서상 최대한 빠른 문자열이 되도록 변경하는 문제이다.
주어진 조건을 모두 만족하게끔 직관적으로 코드를 짰더니, 모든 TC 및 반례까지 통과했지만
시간초과가 어마어마하게 떴다. 결국 아래 블로그를 통해 도움을 얻었는데
"110"을 찾을 때 indexof를 쓰면 안되고, stack을 써서 찾아야 하며 stringbuilder를 꼭 써야한다고 했다.
위 블로그와 99.9% 유사하게 코드를 재구성했지만 c# 의 한계인지 몇몇 tc는 여전히 시간초과이다.
https://countrysides.tistory.com/90