▶ 가장 긴 팰린드롬.cs (연습문제)
처음에는 팰린드롬 체크를 Stack을 이용하고 substring을 이용해서 팰린드롬 메서드에 넘겨주었더니
TC 1개에서 시간초과가 떴다. 그래서 팰린드롬 체크와 부분문자열을 모두 index로만 이용해서 풀었더니
해결되었다. 알고리즘은 문자열의 최대길이부터 -1 씩 해보면서 해당 길이의 부분문자열 팰린드롬이 문자열내에
존재하는지 모두 검사해보면 된다. 가장 먼저 찾게되는 길이가 최대의 길이가 된다.

▶ 멀리 뛰기.cs (연습문제)
한번에 1칸 혹은 2칸만 이동할 수 있고 가야할 총 거리가 주어졌을 때 해당 거리를 갈 수 있는 모든 경우의 수를 구하는 문제
처음에는 당연히 순열과 조합을 이용해서 푸는 문제일 줄 알았으나, 거리가 1일때 2일때 3일때 4일때... 결과값을 보아하니
규칙이 존재하는 것을 발견했다. 결국 DP 문제라는 것을 파악하고 점화식을 세워 풀어냈다.
(3레벨은 아닌 것 같다.)

▶ 야근 지수.cs (연습문제)
주어진 n을 갖고 현재 남은 작업량 시간들의 제곱 합을 최대한 작은값으로 만드는 문제
-> 그저 최대값에서 -1씩 해주면 전체 값들이 평등해지며 제곱합 값이 작아질 것으로 예상했다.
-> 우선순위 큐가 사용하기 적합한 자료구조라 생각해 사용했다.

▶ 입국심사.cs (이진탐색)
처음에는 미숙하게도 시간을 세는 cnt 변수를 하나 이용해 모든 심사관 앞에서 기다려야 할 시간을 구하고
해당 시간들을 정렬하여 가장 작은 값을 찾아내려 했다. 하지만 이런 방식은 logn을 n번 해야하니 결국 nlogn이 걸려
시간초과가 날 것이라는 것을 깨달았다. 그리하여 단 한번의 이분탐색 루프를 통해 값을 찾아야 했다. 

이진 탐색으로 접근하게 되면 어떤 값을 기준으로 범위를 좁혀 나가면서 답을 찾아내야 할지 생각한다.
문제에서는 모든 사람이 심사를 받는데 걸리는 시간의 최솟값 을 요구 했으니 시간 을 기준으로 범위를 잡아본다.
start는 가장 최솟값이므로, 기다리는 사람 수가 1이고 심사 시간이 1분만 걸리는 심사관 밖에 없을 때를 생각해본다면 1이 나온다.
end 역시 시간을 기준으로 생각했을 때, 심사 시간이 가장 오래 걸리는 사람에게 n명 모두 갔을 때이다.
 => times[times.size()-1] * n

start와 end 범위를 잡았으니 이진 탐색을 시작한다.
좀 헷갈렸던 부분이 cnt 라는 변수 인데, ★이 cnt 는 시간이 아닌 mid 시간동안 심사 처리할 수 있는 모든 사람 수를 의미한다.★
그래야 이 cnt 값으로 최소 시간을 찾을 수 있기 때문이다.
그래서 cnt(mid 시간 동안 심사 처리할 수 있는 모든 사람 수) 가 기존 n(기다리는 사람 수) 보다 작으면
 해당 문제 조건을 만족하지 못하기 때문에 최솟값인 start 를 mid +1로 갱신해서 다시 탐색을 한다.
그리고 cnt가 만약 n명 이상을 충족했을 때는, end 값을 다시 갱신해준다 (end = mid - 1)
9번 조건을 만족했을 때, 탐색하는 기준 시간(mid)이 최대값(end) 보다 작으면 문제 조건을 충족하기 때문에
★mid 값이 최소 시간이 될 수 있다는 의미다. 따라서 answer에 계속 갱신해준다.★
이를 while 문의 조건인 start <= end 일 때까지 계속 반복하다보면 모든 사람이 심사를 받는데 걸리는 시간의 최솟값이 나온다.

tip.
해당 문제를 풀때 end = times[times.size()-1] * n; 로 구하는데 여기서 times[times.size()-1]와 n은 모두 int 형이기 때문에
결과값도 int로 반환되어 overflow가 일어난다. 고로 둘 다 (long)으로 명시적 형변환을 해주어야 한다.
-> end  = (long)times[times.size()-1] * (long)n;

▶ 네트워크.cs (DFS, BFS 그래프) ★★★
인접행렬로 주어진 그래프내에서 연결그래프가 총 몇개 존재하는지 구하는 문제였다.
내 풀이 : 우선 start를 정하고 해당 start로 부터 DFS를 한바퀴 돌리게되면 start와 연결되어있는
모든 정점들은 방문이 될 것이다. 그 이후에 아직 방문되지않은 정점이 존재한다는 것은
해당 정점은 새로운 연결그래프로서 존재한다는 의미이므로 해당 정점으로부터 다시 DFS를 돌린다.
이후는 위와 같이 반복한다. 결국 ★몇번 DFS를 호출하느냐가 그래프의 갯수이다.★

▶ 단어 변환.cs (DFS, BFS 그래프) ★★★
문제 자체는 굉장히 쉽게 풀어낼 수 있었다. 그저 BFS를 통한 최단길이를 찾으면 되는 문제였다.
하지만 단어를 변환해가는 과정을 그래프의 개념과 연관짓는 것, ★즉 한글자만 다를때 변환이 가능한 경우를
길이 존재하느냐 존재하지않느냐라는 개념으로 연관짓는것이 쉽지않았고★ 풀어보고나니 굉장히 참신한 문제라는 생각이 들었다.
여지껏 BFS 문제라하면 문제에 대놓고 그래프 형식이나 행렬이 주어지곤 했는데 전혀 같은 부류의 문제같아 보이지 않았는데
BFS로 연관지어 풀 수 있다는 것에 재미를 느낄 수 있었다.

▶ 가장 먼 노드.cs (BFS 그래프)
출발 노드로부터 가장 먼 노드의 갯수가 몇개인지 즉 가장 먼 길이가 같다면 그 노드의 갯수가 몇인지 구하는 문제였다.
단순히 최단경로를 구하기 위해 BFS를 사용했고, 각 노드에 도착할때마다 출발지점으로부터 몇번의 간선을 지나쳤는지
저장하여 해당 값을 현재의 가장 먼 길이와 비교하며 업데이트해주었다.
최종적으로 모든 노드를 순회하고났을때 저장되어있는 가장 먼 길이와 갯수를 출력해주면 된다.

▶ 순위.cs (그래프, 플로이드 와샬 알고리즘) ★★★
(처음에는 플로이드 와샬에 관해 떠올리지 못해서 블로그를 참고했다.)
복싱선수간 승패결과를 단일방향그래프로 나타내고 순위가 확정된 선수의 수를 반환하는 문제였다.

★순위가 확정되려면 나머지 모든 선수와의 경기결과를 알 수 있어야 한다는 점이 중요하다.★
-> 더불어 a가 b를 이기고 b가 c를 이기면 a는 c를 이긴다는 점!! 이 점을 이용해 플로이드 와샬 알고리즘을 적용한다.★★

최종적으로 승패결과들을 모두 그래프에 적용시키고나서 각 선수마다 모든 선수와의 경기결과를 갖고있는지 판별하면 된다.

▶ 디스크 컨트롤러.cs (힙, SJF 알고리즘) ★★
프로세스 스케줄링 알고리즘 중 SJF(비선점) 알고리즘을 구현하는 문제다.
현재 작업중인 프로세스의 종료 이전에 요청된 작업들 중 가장 작업시간이 짧은 작업을 선택하도록 힙을 구현하여
풀 수도 있지만, 단순하게 리스트를 정렬하여 풀어낼 수 있는 문제여서 힙을 구현하지는 않았다.
모든 작업들을 1. 요청 시간이 빠른 순서 2. 요청 시간이 같다면 작업시간이 짧은 순서로 정렬 한 후
현재 curEnd 시간 이전에 요청된 작업들을 찾고 그 중 작업시간이 가장 짧은 것을 수행시키는 방식으로
또한 수행 후 curEnd를 적절히 업데이트 시켜주는 방식으로 풀어낼 수 있다.

▶ 이중우선순위큐.cs (힙 - 이중 우선순위 큐) ★
https://ansohxxn.github.io/programmers/kit14/

맥스힙, 민힙 2개의 힙을 동시에 운영하면서 문제를 풀어나가면 된다.
다만 Delete 연산 시에 두 힙에 존재하는 같은 숫자를 모두 제거해주거나 -> (배열로 구현한 heap은 복잡해짐)★
(애초에 우선순위큐를 제공하는 언어는 정말 손쉽게 두 큐의 같은 숫자를 제거해주면서 풀어낼 수 있음.★★)
혹은 하나의 힙에 대해서만 삭제한 후 두 힙의 최상단값을 비교해가면서 풀어낼 수 있다.

▶ 베스트앨범.cs (해시) ★★
해시 문제인 만큼 최대한 해시, 딕셔너리를 사용하려고 노력했다.
장르의 이름을 키로 사용하며, value에는 해당 장르에 속한 모든 노래의 고유번호와 플레이 횟수를 원소로 갖는 리스트를 할당했다.
그 후 각 리스트들을 문제에서 제시한 조건대로 정렬해주었다.
-> 이후에는  List<KeyValuePair<string, int>> sortList를 선언하여 key를 장르의 이름으로 사용하고,
 value는 장르에 속한 곡들의 총 플레이횟수를 할당했다. 해당 리스트를 총 플레이 횟수로 정렬하게되면
어떠한 장르의 순서대로 2곡씩 뽑아야하는지 알 수 있게된다.
고로 해당 리스트의 원소 순서대로 각 장르이름을 dict의 key로 사용해 곡들의 리스트를 불러내고
해당 리스트에서 정렬되어있는 순서대로 최대 2곡씩 뽑아서 추가하면 정답이 나오게 된다.

▶ 여행경로.cs (DFS, BFS 그래프) ★★★★
문제에서 주어지는 설명과 TC가 너무 부실하다고 느꼈고, 역시나 문제를 제대로 이해하지 못한 탓에
코드를 여러번 갈아 엎었다.
ICN 부터 출발하여 모든 경로를 돌아야하는 문제이다. 알파벳 순으로 이동하라고는 했지만 알파벳 순으로 이동했다가
모든 경로를 돌 수 없는 경우가 많이 생긴다. 고로 알파벳 순으로 정렬은 하되, 해당 알파벳 순으로 경로를 시작한다고 해서
무조건 원하는 경로를 얻어낼 수는 없다는 의미이다. 고로 해당 경로로 출발했을 때 원하는 답을 얻을 수 있는지 체크해보고
얻을 수 없다면, 알파벳 순이 느리더라도 다음번 경로를 통해 다시 시작해보아야 한다.
-> ★★ DFS를 재귀호출 할 때 반환값으로 bool을 넘겨주는 방식으로 구현하는데 해당 방식으로 하면 꽤나 깔끔한 코드 작성이 가능하다.
https://ansohxxn.github.io/programmers/kit30/ 참고함.