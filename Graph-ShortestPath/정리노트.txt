▶ 1753.cs
다익스트라 알고리즘을 복기하는데 좋은 문제였다. 처음에는 시간초과가 떴는데 그 이유는
아직 방문되지않은 최단거리 노드를 찾을때 우선순위 큐를 사용하지 않았기 때문이다.
그리고 대부분 다익트스라 문제는 그래프를 인접리스트로 구현해야 시간초과가 나지 않는것 같다.

▶ 1504.cs  9370.cs
무방향 그래프내에서 최단거리를 구하는데, 특정 정점을 꼭 거쳐가는 경로에 대한 최단거리를 구해야하는 문제이다.
예를들어 n1, n2 정점을 꼭 거쳐야한다면 1 -> n1 -> n2 -> 도착점 혹은 1 -> n2 -> n1 -> 도착점과 같은 경로
혹은 그 이상의 다른 경로또한 두 정점만 거칠 수 있고 최단을 만족한다면 가능하다.
처음 이 문제를 봤을때 1정점부터 n1까지의 최단거리 + n1부터 n2까지의 최단거리 + n2부터 도착점까지의 최단거리를
구해주면 될 것 같았다. 그래서 플로이드 알고리즘을 사용하는것이 더 효율적일까 생각해봤지만, 무슨 이유에서인지
다른사람들의 풀이는 다익스트라를 응용했길래 나또한 다익트스라를 이용해서 푼 문제이다.
위에 설명한 두 경로에대해서 1 -> n1 다익스트라값 + n1 -> n2 다익스트라값  + n2 -> n 다익스트라값을 모두 더한 후
 1 -> n2 다익스트라값 + n2 -> n1 다익스트라값  + n1 -> n 다익스트라값과 최소값을 비교하면 된다.

▶ 11657.cs 
만약 그래프내에 음의 가중치가 존재한다면 어떻게 최단거리를 구할 수 있을까?
다익스트라 알고리즘은 오직 양의 가중치 그래프에서만 작동한다. 이럴때 사용하는 것이 벨만포드 알고리즘이다.
이 문제를 통해 벨만포드의 개념과 c, c# 두 버전의 알고리즘을 모두 작성해보는 계기가 되었다.

▶ 11404.cs 
만약 모든 정점간의 최단거리를 구하려면 어떻게 해야 할까?
다익스트라를 n번 수행하는 것은 너무 비효율적이다.. -> Floyd 알고리즘을 사용하면 된다.
Floyd 알고리즘은 모든 정점간의 최단거리를 구해주는 알고리즘이다.

distance 배열을 2차원으로 선언해 모든 정점간의 최단거리를 나타내주고 초기화한다.

0번 정점을 지나는 경우 vs 0번 정점을 지나지 않고 곧장 가는 경우..
1번 정점을 지나는 경우 vs 1번 정점을 지나지 않고 곧장 가는 경우..
2번 정점을 지나는 경우 vs 2번 정점을 지나지 않고 곧장 가는 경우..
3번 정점을 지나는 경우 vs 3번 정점을 지나지 않고 곧장 가는 경우..
4번 정점을 지나는 경우 vs 4번 정점을 지나지 않고 곧장 가는 경우..
...
위와같이 모든 정점에 대해 지나는 경우 vs 지나지 않는 경우를 따져주게되면 귀납법에 의해 최단거리가 구해지게 된다.

▶ 1956.cs 
그래프내에 최소의 거리를 갖는 사이클을 찾는 문제이다.
시작 -> 도착 + 도착 -> 시작 이 최소값이 되는 사이클을 찾아야 하기 때문에 모든 정점간의 최단거리를 알 수 있는
플로이드 알고리즘을 적용해야 한다고 생각했다. 플로이드 알고리즘을 통해 모든 정점간 최단거리를 구하고
0 -> 1 + 1 -> 0 ... 0 -> 2 + 2 -> 0... 모두 검사하며 최소값을 찾아내면 된다.
