▶ 11725.cs
리스트로 트리를 구현한 후 각 노드마다 부모노드를 출력해주는 문제이다.
전중후 순회가 DFS에 포함된다는 것을 이 문제를 풀면서 깨달았다.. 여튼 DFS를 통해서 모든 노드를 순회하며
현재 노드가 자식노드의 부모이므로 해당 값을 Parent[] 배열에 저장하며 순회했다.
★주의해야 할 점은 list에 자식에 대한 정점번호를 저장할때 한 방향으로만 저장하면 될 줄 알았는데 문제에서 연결정보를 줄때
무조건 부모, 자식 순서로 주지않고 뒤죽박죽 주기 때문에 start -> end, end -> start 모두 저장해준 후
visited[] 배열을 통해서 이미 방문한 부모노드를 걸러내주어야 한다.★

▶ 1167.cs
DFS, BFS를 이용해서 트리내에서 가장 멀리있는 정점간의 거리를 구하는 문제이다.
임의의 노드를 루트로 잡고 해당 노드를 루트로했을때 가장 최장거리를 구하는 DFS는 혼자 구현했지만
해당 문제는 루트를 주어주지 않았기 때문에, 모든 노드마다 루트로 집어넣어가며 비교해야하는지 고민했다.
하지만 정점의 최대갯수가 10000개 정도로 너무 많았기 때문에 다른 방법이 있을 것이라 생각했다.
결국 힌트를 찾아보게 되었는데 임의의 노드를 루트로하고 DFS를 돌렸을때 가장 멀리있는 노드는
트리에서 가장 바깥 부분에있는 노드를 찾게되고 해당 노드를 루트로 했을때 나오는 값이 이 문제의 답이라는 사실을
알아냈다.. 힌트를 보지 못했다면 풀지 못했을 것 같다.

▶ 1967.cs
1167.cs 와 동일한 문제이다. 그림을 통해서 문제를 설명해주니 1167에서 봤던 힌트가 제대로 이해간 것 같다.
이 문제는 n == 1일 때 예외 처리를 꼭 해주어야 한다..

▶ 1991.cs
트리를 직접 구현해보고 전,중,후위 순회를 구현해보는 문제이다.
트리를 c언어로만 구현해봤더니 c#으로 곧장 구현하기가 나름 헷갈렸다.
트리에 노드를 삽입할때 root가 null인경우와 그렇지 않은 경우를 나누어야 하고
root가 null이 아니라면 노드를 삽입하고자하는 위치를 트리를 DFS(전중후위), BFS로 순회하며
찾은 후 삽입해야 한다.★

▶ 2263.cs
inorder와 postorder가 주어졌을때 preorder를 구하는 문제로 상당히 애를 먹었던 문제이다.
postorder의 마지막 원소가 inorder의 루트를 이룬다는 점을 찾아내었고 해당 원소를 기점으로 inorder 내에서
트리가 좌, 우로 나뉜 다는 것을 알 수 있었다. 여기서 좌, 우에 대해 분할정복 기법으로 풀어나가야 하는데
inorde와 postorder의 인덱스를 같이 운용해야하다보니 꽤 헷갈렸던 문제이다. 다시한번 풀어봐야겠다.