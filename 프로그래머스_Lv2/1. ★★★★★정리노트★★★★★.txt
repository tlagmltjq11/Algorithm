백준에 익숙해지다 보니 프로그래머스가 좀 불편하다.. 사용자 입력으로 받는게 오히려 데이터를 다루기 편한 것 같다.

▶ 올바른 괄호.cs (스택)
괄호가 올바르게 구성된 문자열인지 판별하는 문제이다.
닫힘 괄호를 만났을때엔 닫힘 괄호와 가장 가까운 열림괄호를 찾아야 한다.
고로 LIFO의 구조를 갖는 스택 자료구조를 사용해 열림괄호를 만날때마다 스택에 저장해주면 된다.

▶ 괄호 회전하기.cs (스택)
올바른 괄호와 같은 문제.

▶ 짝지어 제거하기.cs ★ (스택)
주어진 문자열에 같은 문자가 2번 연속 나타나면 해당 2문자를 잘라내고 앞뒤를 이어붙이는 식으로 문자열을 아예 소거시킬 수 있는지
판단하는 문제이다.
처음에는 단순히 fisrt = 0, second = 1; 2개의 iter변수를 통해서 문자열을 반복적으로 순회하며 문자열을 잘라내고 이어붙이기를
했는데 시간초과가 떴다. 그래서 second가 문자열의 절반 이상으로 넘어가면 어차피 같은 문자를 찾아도 전체의 문자열을 소거시킬 수
없다는 아이디어를 통해, 탐색범위를 절반으로 줄여주었는데도 시간초과가 났다.

-> 문제를 다시 풀어보니 stack을 이용하면 O(n)만에 풀리는 아주 간단한 문제였다.

▶ 기능개발.cs ★ (큐)
작업량과 작업의 스피드가 주어졌을때 순서상 자신의 앞에 존재하는 모든 작업이 끝나야만 자신의 작업도 처리 되는 상황에서
한번에 처리되는 모든 작업의 수 들을 모든 작업이 끝날때까지 저장하면 되는 문제이다.
문제 자체는 이런저런 설명이 많지만 풀이는 간단하다. 작업량과 작업의 스피드를 이용해 (나누기 연산) 실제 각 작업들이
끝나는데 까지 소요되는 일을 모두 구한다. 해당 day값들을 큐에 순서대로 넣고 큐가 빌때까지 즉 모든 작업이 처리될때 까지
다음을 반복한다.
1. 큐의 맨앞 값을 꺼내 temp에 저장
2. 반복을 돌며 큐의 맨앞에 저장되어 있는 값이 temp 보다 작다면 cnt++  -> 해당 값들은 temp가 처리될때 함께 처리되는 것들
3. 만약 temp 보다 크다면 현재의 cnt값을 answer에 저장 후 temp 값을 큐의 맨앞 값으로 변경 -> 동시에 처리되지 않는 작업
4. 큐가 비게되면 끝.

▶ 다리를 지나는 트럭.cs ★★ (큐)
먼저 다리에 들어간 트럭이 먼저나오기 점을 고려해 큐를 사용해보는 문제이다.
1. 대기하는 차량이 1대 이상 존재하고, 차가 도로위에 올라갈 수 있다면 도로에 진입시킨다.
2. 대기하는 차량이 있지만 도로에 차가 올라갈 수 없다면 차량이 나갈때까지 시간을 보낸다.
3. 도로에 올라가있는 차량은 시간이 지날수록 남은 거리가 줄어든다.
4. 대기하는 차량이 없어도 도로에 차가있다면 시간을 계속 체크해야 한다.
5. 대기차도 없고 도로에 올라간 차량도 없다면 반복문 종료

알고리즘 자체는 위와같이 심플하게 진행할 수 있다.

하지만 구현에있어서 다리에 올라간 트럭마다 다리를 전부 건넜는지 안건넜는지 판별하기 위해
time을 컨트롤해야하는 점이 꽤 헷갈렸던 문제이다.

▶ 주식가격.cs (큐)
주어진 각 주식 가격이 몇초간 떨어지지않고 지속되었는지 판별하는 문제이다.
앞에서부터 차례대로 비교해야하기 때문에 큐를 이용하게끔 유도한 문제 같지만
오히려 큐를 사용하면 비효율적으로(큐는 인덱스 접근이 안되기에) 코드가 구성되기에 배열을 사용하여 풀어냈다.
순차대로 비교해주면서 기준이되는 주식가보다 작은 값이 나오면 반복을 멈춰주고 현재까지의 cnt를 답에 추가해주면 된다.

▶ 124 나라의 숫자.cs ★★
먼저 숫자가 1,2,4 3개 뿐이므로 3을 이용한 나머지 연산이 문제풀이의 핵심이 될 것이라는 것은 바로 파악을 했다.
하지만 나머지가 1이면 1을 2이면 2를 붙여줘야 한다는 점은 알았지만 나머지가 0일 때 4를 붙여주며 동시에 n을 -1 해줘야
알맞는 숫자가 나온다는 점을 파악하는데 시간이 좀 걸렸다.
또한 값을 앞에다 붙여줘야 한다는 점 주의!!

n = 5 일 때

1) n % 3 = 2 
   n = n / 3 = 1
2) n % 3 = 1
   n = n / 3 = 0
   
답은 numbers[1] + numbers[2] = "12"

▶ 프린터.cs (큐)
큐내에서 계속 위치가 변하는 대상에 대해 처음 주어진 location의 그 값인지 판단하기 위해
keyvaluepair를 사용했다. 또한 인덱스 접근이 불가능한 Q이기에 foreach로 순회한 것이 포인트이다.

▶ 문자열 압축.cs (문자열)
앞에서부터 문자들을 차례대로 비교하며 중복된 수 만큼 카운트해주며 붙이고 다른 문자열이 나오면
현재의 문자열을 해당 문자열로 교환해주고 cnt를 1로 변경시켜 다시 순회하면 된다.
하지만 문자열 끝자락에 현재 압축단위보다 짧은 길이의 문자만이 남았다면 해당 부분을 처리해줘야 한다.
압축단위를 주어진 문자열 길이의 절반까지만 수행해도 된다는 점을 파악해야 수행시간을 줄일 수 있다.
-> 절반 이상이되면 비교의 의미가 없어짐

▶ 게임 맵 최단거리.cs ★★ (BFS)
0, 0 에서 4, 4까지의 경로 중 최단거리를 구하는 문제. 고로 BFS를 통해 풀어내면 된다.

▶ 카카오프렌즈 컬러링북.cs ★★ (DFS, BFS)
DFS나 BFS를 통해서 각 영역을 체크해 영역의 수와 가장 큰 영역의 넓이를 구하면 되는 문제이다.
이번에는 stack을 이용해서 재귀가아닌 반복문의 형태로 DFS를 구현해보았다.
stack으로 구현할때 주의 할 점은 스택에서 하나의 정점을 꺼냈을때 해당 정점이 이미 방문된 정점인지 아닌지 파악해주어야 한다.

0,0 0,1 0,2
1,0 1,1 1,2

해당 좌표에서 0,0 부터 상하우좌 순서로 스택에 집어넣는다고 가정하면

1단계	2단계	3단계	4단계	5단계	6단계
0,1	0,2	1,2	1,1	1,0	1,1
1,0	1,1	1,1	1,1	1,1	1,0
	1,0	1,0	1,0	1,0

위와 같이 4~6단계에서 1,1 1,0이 중복되어 들어가는 것을 볼 수 있다. 고로 스택에서 정점을 하나씩 꺼낼때
이 정점이 이미 방문되었는지를 판단해주어야 한다. 만약 이미 방문되었다면 이 문제에서는 영역의 넓이를 구하는
cnt++을 해주면 안될 것이다.★★★

▶ 조이스틱.cs ★★ (탐욕)
문제의 해법은 빠르게 찾아냈다. 생각해낸 방식은 (첫 시작 인덱스는 항상 0번 인덱스) 현재의 인덱스에 존재하는 문자에 대해서
위로 혹은 아래로 가는 방식 중 더 적게 소모되는 값을 answer에 더해주고 현재의 위치에서 가장 가까운
'A'가 아닌 문자의 위치로 이동시키며 해당 이동값을 더해주는 방식을 이용한다면 그리디하게 최소의 값을 구할 수 있을 것이라
판단했다. 하지만 c#으로 구현하는데 string 의 readonly 문제 등 여러가지 문제가 겹쳐 c++로 구현해서 제출한 문제이다.
다시한번 구현에 도전해봐야 한다.

▶ 큰 수 만들기.cs ★ (탐욕)
Greedy 문제로 n개의 수에서 m개를 제거했을때 만들 수 있는 가장 큰 수를 만들면 되는 문제이다.
처음 접근할때 맨 앞자릿수가 크기의 가장 큰 영향을 미치기 때문에 앞자릿 수 부터 최대한 크게 결정해나가면 될 것이라
생각했다. 그래서 n=7, m=3 이라고 한다면 최대 4자리는 확보를 해둬야 하기 때문에 <<-- 가장 중요한 포인트 ★★★
인덱스 0~3 범위에 존재하는 4가지 숫자 중 가장 큰 값을 천의 자리로 고정시키게끔 했다. (ex) 천의 자리 인덱스 = 2
그 다음은 백의 자리를 찾아야 하는데 앞서 천의자리 값보다 앞에 존재하는 수들은 이미 제거되어 사용할 수 없으므로
3 ~ 4 에서 백의자리를 찾아야 했다. 이런식으로 4자리의 수를 만들어주면 최대 값이 나오게 된다.
하지만 분명 예전에 풀어둔 c++ 코드보다 효율적이고 빠르게 짰는데도 c#은 시간초과가 났고  c++은 가볍게 통과했다....

▶ 구명보트.cs ★ (탐욕)
보트에는 2명까지 탈 수 있고 무게제한이 존재한다. 사람들의 무게가 주어졌을때 최소의 보트 수를 구하는 문제.
물론 보트의 적재가능 무게를 꽉채우도록 사람을 태워야 최소의 보트 수로 구출이 가능하다는 것을 알 수 있을 것이다.
고로 사람들의 무게 배열을 정렬한 후 left, right 변수를 운용하며 가장 무거운사람과 가장 가벼운 사람을 동시에 태울 수 있는지
파악한다. 가능하다면 left++ right-- 후 보트의 수를 + 1 더해준다. 만약 태울 수 없다면 무거운사람 혼자 보낸다.
이렇게 탐욕적인 반복을 수행하면 해결되는 문제이다.

▶ 단체사진 찍기cs ★★★★ (순열-완전탐색)
주어진 조건에 맞게끔 순열을 구할 생각을 했는데, 그 반대로 순열을 구하고 조건에 맞게 걸러내야 했던 문제이다.

▶ 수식 최대화cs ★★★★★ (순열 + 문자열처리)
연산자를 기준으로 양옆 숫자를 문자열에서 직접 뽑아 추출하려다가 여러번 실패를 맛본 문제이다.
애초에 전체 문자열에서 숫자와 연산자를 각각 리스트에 뽑아 관리하면서 처리하면 훨씬 간단하게 코드를 구성할 수 있다.

▶ 소수 찾기.cs ★★★ (완전탐색)
완전탐색 문제로 가능한 모든 순열을 구해 소수의 총 갯수를 파악하면 되는 문제이다.
완전탐색에는 여러 알고리즘을 적용할 수 있다.

▶ 메뉴 리뉴얼.cs ★★ (완전탐색)
제시하는 조건이 여러개라 구현이 까다로웠던 문제이다.
orders 문자열은 내부적으로 정렬이 안되어있어 하나하나 정렬 후 매개변수로 넘겨줘야한다는 점을 유의하자.
또한 조합에 대해서 좀더 공부해야한다.

▶ 가장 큰 수.cs ★★★ (정렬)
30, 3 이 있을때 330 과 303 중 330이 크기 때문에 3이 먼저 선택되어야 더 큰 수를 만들 수 있다.
이러한 규칙에 따라 모든 수를 정렬하고 차례대로 문자열에 붙여주면 된다.

▶ 더 맵게.cs (힙)
새로운 수 = 가장 작은 수 + (두번째로 작은 수 * 2) 와 같은 공식으로 주어진 모든 수를 K이상의 수로 만들어내는 문제이다.
새로운 수를 만들어내는데 2가지의 수가 쓰이므로 공식한번에 갯수가 1개씩 줄어드는 점을 주의하자.
우선 주어지는 수의 최대갯수가 컸기 때문에 일반적인 순차탐색을 통해 최솟값 2개를 구하는 것은 시간초과가 날 것이라 예상했다.
고로 c#에서 기본으로 제공하지 않는 최소힙을 구현해 풀어냈다. 
예외사항은 공식을 계속해서 적용해나갔을때 1가지의 수가 남은 경우이다. 만약 해당 한가지의 수가 k이상이 아니라면
더이상 공식을 진행하지 못하므로 -1을 출력한다.

▶ 오픈채팅방.cs ★★ (딕셔너리)
결국 최종적으로 결정된 닉네임을 Log로 출력해주어야 하기 때문에, 우선 로그를 한바퀴 돌면서 uid에 맞는 최종 닉네임을
결정해준다. 그 후 다시 로그를 한바퀴 돌면서 최종 결정된 닉네임을 대치시켜서 로그를 문자열로 출력시켜주면 되는 문제이다.
uid, nickName 의 쌍으로 관리해야하기 때문에 딕셔너리를 이용하면 편하다.

▶ 위장.cs ★ (딕셔너리)
해싱을 사용하는 Dictionary와 같은 자료구조를 이용해 같은 key를 갖는 값들을 모아준 후 처리하면 되는 문제이다.
 위 문제의 경우의 수 공식은 다음과 같다. 착장을 위한 옷의 종류가 <외투, 모자, 안경>으로 구분될 경우
( ( 외투의 갯수 + 1 ) * ( 모자의 갯수 + 1 ) * ( 안경의 갯수 + 1 ) ) - 1
모든 경우의 수를 구할 경우 각 종류의 갯수를 곱해주면 되지만,
해당 옷의 종류를 선택하지 않을 경우를 포함하기 떄문에 종류의 갯수에 +1 을 해주고
아무것도 선택하지 않는 경우는 없기 때문에 마지막에 -1을 해준다.

▶ H-Index.cs (정렬)
간단히 오름차순 정렬 후 뒤에서부터 순회하며 남은 갯수보다 작아지는 숫자가 있을 때 리턴할 숫자를 판단하면 된다.

▶ 카펫.cs ★★ (완전탐색)
brown + yellow가 전체 정사각형의 넓이가 된다는 점을 주의해야 한다.
또한 가운데 채워진 yellow의 값은 (세로-2) * (가로-2) 가 된다는 점도 파악할 수 있어야 한다.
위 공식들을 만족하는 높이를 3부터 시작해서 찾아내면 된다.

▶ 다음 큰 숫자.cs (연습문제)
십진수를 이진수로 변환하는 방식만 알면 쉽게 해결되는 문제이다.
주어진 십진수가 0보다 클 동안 2로 나눈 나머지를 계속해서 덧붙여주면 된다. (물론 십진수 /= 2도 계속 진행)

▶ 최댓값과 최솟값.cs (연습문제)
sort만 쓸 줄 알면 푸는 매우 간단한 문제.

▶ 숫자의 표현.cs (연습문제)
이중 반복문을 구성할 줄 알면 푸는 매우 간단한 문제.

▶ 최솟값 만들기.cs (연습문제)
A배열은 오름차순 B배열은 내림차순으로 정렬한 후
각 배열의 원소를 순서대로 곱하여 더해주면 값이 나온다.
원리는 각 A 배열의 가장 큰 수를 B배열의 가장 작은 수와 곱하기로 매칭시켜서 최대한
큰 수의 곱셈을 작은 값으로 만드는 것이다. B배열의 가장 큰 수도 마찬가지로 A배열의 가장 작은 수와 곱셈 매칭이 된다.

▶ 피보나치 수.cs (연습문제)
재귀로 구현하면 시간초과가 나기 때문에 DP를 이용해서 구현해야 한다.

▶ 예상 대진표.cs (연습문제)
(현재 자신의 번호 + 1) / 2가 다음 라운드에서의 번호라는 점만 파악하면 된다.

▶ jadenCase 문자열 만들기.cs (연습문제)
대체 왜 애먹은지 모르겠는 문제.
공백이 2개 이상 포함되어있을 수 있다는 점을 자각하지 못해서 애를 먹었다.
또한 이전 char 값이 공백이라면 현재 char 값이 각 문자열의 첫 문자라는 점을 파악하자.★

▶ 행렬의 곱셈.cs (연습문제)
행렬의 곱셈을 구현하는 문제로 쉽게 구현 가능한 문제.

▶ 행렬 테두리 회전하기.cs (연습문제)
문제에서 제시하는대로 직관적으로 구현해주면 되는 문제이다.
주어진 범위의 행렬값을 실제로 시계 방향으로 돌려주면 된다.

▶ N개의 최소공배수.cs ★ (연습문제)
n개의 수의 최소공배수를 구하는 문제.
n[0] 과 n[1]의 최소공배수를 구하고 해당 최소공배수와 n[2]와의 최소공배수를 구하는 방식으로
모든 수의 최소공배수를 구할 수 있다. 

무엇보다 최소공배수를 구하는 알고리즘을 인지하고 있어야 한다.★

▶ 땅 따먹기.cs ★★★ (DP) 
2차원 배열에서 같은 열을 밟지않고 내려오며 최댓값을 만드는 문제이다.
처음에는 모든 경우의 수를 구해야하나 했지만 행의 최대 갯수가 너무커서 시간초과를 예상하여 시도하지 않았다.
메모이제이션을 활용한 DP를 활용해야 하는 문제라는 것을 깨달았다.
현재위치까지 올 수 있는 최댓값을 DP를 이용해서 다음과같이 구해야 한다.

//같은 열이 아닌 경우 
if(j != k)
	//최댓값 갱신
	dp[i, j] = Math.Max(dp[i, j], land[i, j] + dp[i - 1, k]); 

DP자체를 연습을 많이 해야한다는 것을 깨달음.

▶ 가장 큰 정사각형 찾기.cs ★★★★★ (DP) 
DP로 풀어야한다는 사실은 파악했지만 점화식을 찾지 못해서 결국엔 예전 풀이를 참고했던 문제이다.
0과 1로 구성된 2차원 배열내에서 가장 큰 정사각형의 넓이를 구하는 문제이다.
min 값을 사용해야 하는 이유는 현재 위치에서 더 큰값으로 뻗어나가면 더 작은값에 의해서 직사각형으로 구성되기 때문이다.
왼쪽위 대각선값과도 비교해야 하는 이유는 해당 정사각형의 가운데가 차있는지 파악하기 위함.
정확한 풀이는 아래 링크를 참고하자.
https://simyeju.tistory.com/50

▶ 영어 끝말잇기.cs (HashSet)
이미 단어가 이전에 나왔던 단어인지 판별하기 위해서 중복을 허락하지않는 HashSet(집합) 자료구조를 사용했다.

▶ 멀쩡한 사각형.cs ★★ (gcd)
직사각형의 두 꼭지점을 이은 대각선에 포함되는 사각형의 갯수를 구하는 문제.
https://taesan94.tistory.com/55 블로그를 통해 문제 해설 참조하기.
-> 더 좋은 풀이 https://velog.io/@jaesika/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A9%80%EC%A9%A1%ED%95%9C-%EC%82%AC%EA%B0%81%ED%98%95-with-Java

▶ 괄호 변환.cs (구현)
https://taesan94.tistory.com/137

▶ 후보키.cs ★★★★★(set, 조합)
c# 제출이 없어서 정답을 아직 확인하지 못했고 대부분의 TC는 통과하지만
로직이 틀린 부분이 있는 것 같아 다시 풀어봐야 함.★★★


