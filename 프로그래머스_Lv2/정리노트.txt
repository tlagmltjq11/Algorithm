백준에 익숙해지다 보니 프로그래머스가 좀 불편하다.. 사용자 입력으로 받는게 오히려 데이터를 다루기 편한 것 같다.

▶ 기능개발.cs ★
작업량과 작업의 스피드가 주어졌을때 순서상 자신의 앞에 존재하는 모든 작업이 끝나야만 자신의 작업도 처리 되는 상황에서
한번에 처리되는 모든 작업의 수 들을 모든 작업이 끝날때까지 저장하면 되는 문제이다.
문제 자체는 이런저런 설명이 많지만 풀이는 간단하다. 작업량과 작업의 스피드를 이용해 (나누기 연산) 실제 각 작업들이
끝나는데 까지 소요되는 일을 모두 구한다. 해당 day값들을 큐에 순서대로 넣고 큐가 빌때까지 즉 모든 작업이 처리될때 까지
다음을 반복한다.
1. 큐의 맨앞 값을 꺼내 temp에 저장
2. 반복을 돌며 큐의 맨앞에 저장되어 있는 값이 temp 보다 작다면 cnt++  -> 해당 값들은 temp가 처리될때 함께 처리되는 것들
3. 만약 temp 보다 크다면 현재의 cnt값을 answer에 저장 후 temp 값을 큐의 맨앞 값으로 변경 -> 동시에 처리되지 않는 작업
4. 큐가 비게되면 끝.

▶ 다리를 지나는 트럭.cs ★
먼저 다리에 들어간 트럭이 먼저나오기 점을 고려해 큐를 사용해보는 문제이다.
1. 대기하는 차량이 1대 이상 존재하고, 차가 도로위에 올라갈 수 있다면 도로에 진입시킨다.
2. 대기하는 차량이 있지만 도로에 차가 올라갈 수 없다면 차량이 나갈때까지 시간을 보낸다.
3. 도로에 올라가있는 차량은 시간이 지날수록 남은 거리가 줄어든다.
4. 대기하는 차량이 없어도 도로에 차가있다면 시간을 계속 체크해야 한다.
5. 대기차도 없고 도로에 올라간 차량도 없다면 반복문 종료

알고리즘 자체는 위와같이 심플하게 진행할 수 있다.

하지만 구현에있어서 다리에 올라간 트럭마다 다리를 전부 건넜는지 안건넜는지 판별하기 위해
time을 컨트롤해야하는 점이 꽤 헷갈렸던 문제이다.

▶ 주식가격.cs
주어진 각 주식 가격이 몇초간 떨어지지않고 지속되었는지 판별하는 문제이다.
앞에서부터 차례대로 비교해야하기 때문에 큐를 이용하게끔 유도한 문제 같지만
오히려 큐를 사용하면 비효율적으로(큐는 인덱스 접근이 안되기에) 코드가 구성되기에 배열을 사용하여 풀어냈다.
순차대로 비교해주면서 기준이되는 주식가보다 작은 값이 나오면 반복을 멈춰주고 현재까지의 cnt를 답에 추가해주면 된다.

▶ 124 나라의 숫자.cs ★
먼저 숫자가 1,2,4 3개 뿐이므로 3을 이용한 나머지 연산이 문제풀이의 핵심이 될 것이라는 것은 바로 파악을 했다.
하지만 나머지가 1이면 1을 2이면 2를 붙여줘야 한다는 점은 알았지만 나머지가 0일 때 4를 붙여주며 동시에 n을 -1 해줘야
알맞는 숫자가 나온다는 점을 파악하는데 시간이 좀 걸렸다.
또한 값을 앞에다 붙여줘야 한다는 점 주의!!

n = 5 일 때

1) n % 3 = 2 
   n = n / 3 = 1
2) n % 3 = 1
   n = n / 3 = 0
   
답은 numbers[1] + numbers[2] = "12"

▶ 프린터.cs
큐내에서 계속 위치가 변하는 대상에 대해 처음 주어진 location의 그 값인지 판단하기 위해
keyvaluepair를 사용했다. 또한 인덱스 접근이 불가능한 Q이기에 foreach로 순회한 것이 포인트이다.