백준에 익숙해지다 보니 프로그래머스가 좀 불편하다.. 사용자 입력으로 받는게 오히려 데이터를 다루기 편한 것 같다.

▶ 기능개발.cs ★
작업량과 작업의 스피드가 주어졌을때 순서상 자신의 앞에 존재하는 모든 작업이 끝나야만 자신의 작업도 처리 되는 상황에서
한번에 처리되는 모든 작업의 수 들을 모든 작업이 끝날때까지 저장하면 되는 문제이다.
문제 자체는 이런저런 설명이 많지만 풀이는 간단하다. 작업량과 작업의 스피드를 이용해 (나누기 연산) 실제 각 작업들이
끝나는데 까지 소요되는 일을 모두 구한다. 해당 day값들을 큐에 순서대로 넣고 큐가 빌때까지 즉 모든 작업이 처리될때 까지
다음을 반복한다.
1. 큐의 맨앞 값을 꺼내 temp에 저장
2. 반복을 돌며 큐의 맨앞에 저장되어 있는 값이 temp 보다 작다면 cnt++  -> 해당 값들은 temp가 처리될때 함께 처리되는 것들
3. 만약 temp 보다 크다면 현재의 cnt값을 answer에 저장 후 temp 값을 큐의 맨앞 값으로 변경 -> 동시에 처리되지 않는 작업
4. 큐가 비게되면 끝.

▶ 다리를 지나는 트럭.cs ★★
먼저 다리에 들어간 트럭이 먼저나오기 점을 고려해 큐를 사용해보는 문제이다.
1. 대기하는 차량이 1대 이상 존재하고, 차가 도로위에 올라갈 수 있다면 도로에 진입시킨다.
2. 대기하는 차량이 있지만 도로에 차가 올라갈 수 없다면 차량이 나갈때까지 시간을 보낸다.
3. 도로에 올라가있는 차량은 시간이 지날수록 남은 거리가 줄어든다.
4. 대기하는 차량이 없어도 도로에 차가있다면 시간을 계속 체크해야 한다.
5. 대기차도 없고 도로에 올라간 차량도 없다면 반복문 종료

알고리즘 자체는 위와같이 심플하게 진행할 수 있다.

하지만 구현에있어서 다리에 올라간 트럭마다 다리를 전부 건넜는지 안건넜는지 판별하기 위해
time을 컨트롤해야하는 점이 꽤 헷갈렸던 문제이다.

▶ 주식가격.cs
주어진 각 주식 가격이 몇초간 떨어지지않고 지속되었는지 판별하는 문제이다.
앞에서부터 차례대로 비교해야하기 때문에 큐를 이용하게끔 유도한 문제 같지만
오히려 큐를 사용하면 비효율적으로(큐는 인덱스 접근이 안되기에) 코드가 구성되기에 배열을 사용하여 풀어냈다.
순차대로 비교해주면서 기준이되는 주식가보다 작은 값이 나오면 반복을 멈춰주고 현재까지의 cnt를 답에 추가해주면 된다.

▶ 124 나라의 숫자.cs ★★
먼저 숫자가 1,2,4 3개 뿐이므로 3을 이용한 나머지 연산이 문제풀이의 핵심이 될 것이라는 것은 바로 파악을 했다.
하지만 나머지가 1이면 1을 2이면 2를 붙여줘야 한다는 점은 알았지만 나머지가 0일 때 4를 붙여주며 동시에 n을 -1 해줘야
알맞는 숫자가 나온다는 점을 파악하는데 시간이 좀 걸렸다.
또한 값을 앞에다 붙여줘야 한다는 점 주의!!

n = 5 일 때

1) n % 3 = 2 
   n = n / 3 = 1
2) n % 3 = 1
   n = n / 3 = 0
   
답은 numbers[1] + numbers[2] = "12"

▶ 프린터.cs
큐내에서 계속 위치가 변하는 대상에 대해 처음 주어진 location의 그 값인지 판단하기 위해
keyvaluepair를 사용했다. 또한 인덱스 접근이 불가능한 Q이기에 foreach로 순회한 것이 포인트이다.

▶ 문자열 압축.cs
앞에서부터 문자들을 차례대로 비교하며 중복된 수 만큼 카운트해주며 붙이고 다른 문자열이 나오면
현재의 문자열을 해당 문자열로 교환해주고 cnt를 1로 변경시켜 다시 순회하면 된다.
하지만 문자열 끝자락에 현재 압축단위보다 짧은 길이의 문자만이 남았다면 해당 부분을 처리해줘야 한다.
압축단위를 주어진 문자열 길이의 절반까지만 수행해도 된다는 점을 파악해야 수행시간을 줄일 수 있다.
-> 절반 이상이되면 비교의 의미가 없어짐

▶ 카카오프렌즈 컬러링북.cs ★★
DFS나 BFS를 통해서 각 영역을 체크해 영역의 수와 가장 큰 영역의 넓이를 구하면 되는 문제이다.
이번에는 stack을 이용해서 재귀가아닌 반복문의 형태로 DFS를 구현해보았다.
stack으로 구현할때 주의 할 점은 스택에서 하나의 정점을 꺼냈을때 해당 정점이 이미 방문된 정점인지 아닌지 파악해주어야 한다.

0,0 0,1 0,2
1,0 1,1 1,2

해당 좌표에서 0,0 부터 상하우좌 순서로 스택에 집어넣는다고 가정하면

1단계	2단계	3단계	4단계	5단계	6단계
0,1	0,2	1,2	1,1	1,0	1,1
1,0	1,1	1,1	1,1	1,1	1,0
	1,0	1,0	1,0	1,0

위와 같이 4~6단계에서 1,1 1,0이 중복되어 들어가는 것을 볼 수 있다. 고로 스택에서 정점을 하나씩 꺼낼때
이 정점이 이미 방문되었는지를 판단해주어야 한다. 만약 이미 방문되었다면 이 문제에서는 영역의 넓이를 구하는
cnt++을 해주면 안될 것이다.★★★

▶ 조이스틱.cs ★★
문제의 해법은 빠르게 찾아냈다. 생각해낸 방식은 (첫 시작 인덱스는 항상 0번 인덱스) 현재의 인덱스에 존재하는 문자에 대해서
위로 혹은 아래로 가는 방식 중 더 적게 소모되는 값을 answer에 더해주고 현재의 위치에서 가장 가까운
'A'가 아닌 문자의 위치로 이동시키며 해당 이동값을 더해주는 방식을 이용한다면 그리디하게 최소의 값을 구할 수 있을 것이라
판단했다. 하지만 c#으로 구현하는데 string 의 readonly 문제 등 여러가지 문제가 겹쳐 c++로 구현해서 제출한 문제이다.
다시한번 구현에 도전해봐야 한다.

▶ 큰 수 만들기.cs ★
Greedy 문제로 n개의 수에서 m개를 제거했을때 만들 수 있는 가장 큰 수를 만들면 되는 문제이다.
처음 접근할때 맨 앞자릿수가 크기의 가장 큰 영향을 미치기 때문에 앞자릿 수 부터 최대한 크게 결정해나가면 될 것이라
생각했다. 그래서 n=7, m=3 이라고 한다면 최대 4자리는 확보를 해둬야 하기 때문에 <<-- 가장 중요한 포인트 ★★★
인덱스 0~3 범위에 존재하는 4가지 숫자 중 가장 큰 값을 천의 자리로 고정시키게끔 했다. (ex) 천의 자리 인덱스 = 2
그 다음은 백의 자리를 찾아야 하는데 앞서 천의자리 값보다 앞에 존재하는 수들은 이미 제거되어 사용할 수 없으므로
3 ~ 4 에서 백의자리를 찾아야 했다. 이런식으로 4자리의 수를 만들어주면 최대 값이 나오게 된다.
하지만 분명 예전에 풀어둔 c++ 코드보다 효율적이고 빠르게 짰는데도 c#은 시간초과가 났고  c++은 가볍게 통과했다....

▶ 소수 찾기.cs ★★★
완전탐색 문제로 가능한 모든 순열을 구해 소수의 총 갯수를 파악하면 되는 문제이다.
완전탐색에는 여러 알고리즘을 적용할 수 있다.

▶ 가장 큰 수.cs ★★★
30, 3 이 있을때 330 과 303 중 330이 크기 때문에 3이 먼저 선택되어야 더 큰 수를 만들 수 있다.
이러한 규칙에 따라 모든 수를 정렬하고 차례대로 문자열에 붙여주면 된다.

