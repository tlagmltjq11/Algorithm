▶ 1260.cs
그래프를 c#으로 직접 구현하고 BFS, DFS의 구현을 복기하는데 도움을 주는 문제이다.
기존 c언어로 그래프를 구현할때에는 인접행렬 혹은 연결리스트를 통한 인접리스트로 구현했는데
c#에서는 포인터 연산자가 없다보니 전부 코드를 뜯어고쳐야 했다. 여기까지는 문제가 없었지만
인접리스트를 배열로 관리하는것이 너무 비효율적이고 문제에서 요구하는 작은 정점부터 방문! 이라는 조건을
충족하기에도 매우 비효율적인 구조를 갖고있었다. 그리하여 List를 이용하는 그래프로 재구현하였고
해당 방식이 메모리 관리 측면에서 더 효율적인 방법이라 생각되었다.

▶ 2606.cs
특정 정점과 경로가 존재하는 모든 정점들의 개수를 구하면 되는 문제였다.
고로 DFS, BFS 어느것으로 풀어도 상관없다. 정점에 방문할때마다 카운트만 올려주면되는 단순한 문제이다.

▶ 2667.cs
0과 1로 이루어진 행렬을 차례대로 순회하면서 1값을 갖고있으면서 방문된적이 없다면 해당 숫자는 1개 혹은 그 이상으로
이루어진 단지이게 된다. 고로 해당 정점부터 DFS를 수행해서 해당 단지내에 속하는 모든 정점의 갯수를 세주면 되는 문제이다.
단 인접한 정점들을 체크할때 기존과 다르게 인접행렬 혹은 인접리스트 방식이 아닌 상하좌우로 체크해야 하는 점을
유의하면 된다.

▶ 1012.cs
2667과 동일한 문제로 0과 1로 이루어진 행렬내에서 인접해있는 1들의 그룹 수를 세는 문제이다.
순회하면서 1을 만나게되면 DFS, BFS를 통해 해당 그룹을 모두 0으로 바꾸어주고 그룹의 수를 +1 해주면 되는 
간단한 문제이다.

▶ 2178.cs
가중치가 없는 그래프내에서 두 정점간 최단거리를 구하는 문제이다.
가중치가 없기 때문에 BFS를 이용해서 간단하게 이동거리를 누적해가며 정답을 도출할 수 있다.
BFS는 자신과 바로 연결되어있는 노드를 큐에 넣으며, 이러한 큐는 FIFO에 따라 먼저 들어온 것을 처리하므로
이 두개의 특성이 결합되어 시작위치로부터 간선의 수가 작은 곳 부터 먼저 처리되게 된다.
고로 BFS를 통해서 최단경로 및 거리를 구할 수 있는 것이다.
<그냥 가까운곳부터 처리되니 결국 가장먼저 도착하는 경우가 최단거리인 경우라는 것>

▶ 7576.cs
맨처음에는 분명히 인접한 토마토들이 익기 때문에 BFS문제라는 것은 알았지만 그 외에 진도가 나가질 않았다.
잠시 생각해보니 행렬에서 1값인 즉 익은 토마토들의 좌표를 전부 파악한 후 해당 좌표들로 부터 동시에
BFS를 처리해주면 될 것 같다는 생각이 들었다. 그리하여 익은 토마토들의 좌표를 모두 큐에 넣고
큐에 존재하는 좌표들에 대해서 동시에 BFS를 진행해주었다. 한 사이클마다 동시에 진행되어야 하는 요소들의
갯수를 세고 해당 갯수만큼 BFS를 진행한다면 Day + 1을 해주었는데 이 방식 말고 행렬 자체에 일수를 누적시켜
진행하는 방식이 더 깔끔한 것 같다.

▶ 7569.cs
7576.cs 의 3차원 버전 문제이다. 3차원 즉 상, 하에 대한 인덱스 처리를 추가해주면 된다.
이 문제에서는 7576과 다르게 행렬 자체에 일수를 누적시켜서 BFS가 끝난 후 최댓값을 찾아서
출력해주는 방식으로 좀 더 깔끔하게 해결했다.